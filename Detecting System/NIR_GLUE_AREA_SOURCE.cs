//
// File generated by HDevelop for HALCON/.NET (C#) Version 17.12
//
using System.Collections.Generic;
using System.Threading;
using System.Diagnostics;
using HalconDotNet;
using System.IO;
using Detecting_System;
using System;

public class Result
{
    public int[] four_cyan_ratio;
    public int[] four_yellow_ratio;
    public int[] four_red_ratio;
    public int[] four_ratio;
    public int all_ratio;
    public double minDistance;
    public bool leakage_flag;
    public bool TestTarget;//測試用
    public Result()
    {
        four_cyan_ratio = new int[4];
        four_yellow_ratio = new int[4];
        four_red_ratio = new int[4];
        four_ratio = new int[4];
    }
}

public class Processor
{
    private Dictionary<System.String, double> parameter_set;
    private Mutex param_mux;
    private bool template_ready = false;
    //Parameters
    #region
    //param-1//
    //thresh_offset:=10
    //Name: 胶水阀值调整 
    //Tooltip: 程式会自动依照照片判定胶水阀值，而此数值则是对程式选取的阀值进行调整，数值越小越容易误判为胶水, 数值越小则越可能漏判为胶水
    //param-2//
    //angle_range:=rad(15)
    //Name: 样品可能角度范围
    //Tooltip: 程式只能接受样品在此角度范围内旋转(已水平为基准)
    //param-3//
    //edge_range:=25
    //Name: 边际光晕效应范围
    //Tooltip: 在边界处会有光晕的现象, 因此必须特别处理, 此数值是界定特别处理的范围(以像素为单位)
    //param-4//
    //ignore_radius:=350
    //Name: 忽略圆的半径
    //Tooltip: 对于落在圆半径的黑色区域，程式会忽略
    //param-5//
    //ncc_filename:='D:/nir/20190822/model'
    //Name: 模板档案路径
    //Tooltip:
    //param-6//
    //glue_min_area:=100
    //Name: 独立胶水的最小面积
    //Tooltip:
    //param-7//
    //high_thresh:=200
    //Name: 亮点大阀值
    //Tooltip: 一团亮点必须起码有一点的灰阶大于此数值才算数
    //param-9//
    //red_cyan_radius:=550
    //Name: 红色青色交界半径
    //Tooltip: 
    //param-10//
    //yellow_red_radius:=520
    //Name: 红色黄色交界半径
    //Tooltip: 
    //param-11
    //red_area_thresh:=0.5
    //Name: 红色区域面积阀值
    //Tooltip: 
    //param-12//
    //cyan_area_thresh:=0.5
    //Name: 青色区域面积阀值
    //Tooltip: 
    //param-13//
    //yellow_area_thresh:=0.5
    //Name: 黄色区域面积阀值
    //Tooltip: 
    #endregion
    private HTuple hv_sample_NCC_ModelID;
    private HTuple hv_empty_NCC_ModelID;
    public int UpdateParameter(System.String parameter_name, double value)
    {
        if (!parameter_set.ContainsKey(parameter_name))
        {
            throw new System.Exception("Parameter name is incorrect, please check it.");
        }
        param_mux.WaitOne();
        parameter_set[parameter_name] = value;
        param_mux.ReleaseMutex();
        return 0;
    }
    #region halcon算子
    public void gen_circle_center(HObject ho_Image, out HObject ho_UsedEdges, out HObject ho_Contour, out HObject ho_ResultContours, out HObject ho_CrossCenter, HTuple hv_InitialRow,
           HTuple hv_InitialColumn, HTuple hv_InitialRadius, HTuple hv_Length, HTuple hv_Measure_Threshold, HTuple hv_MeasureTransition, HTuple hv_MeasureSelect, out HTuple hv_ResultRow, out HTuple hv_ResultColumn, out HTuple hv_ResultRadius)
    {
        // Local iconic variables 

        HObject ho_ModelContour, ho_Contours;

        // Local control variables 

        HTuple hv_MetrologyHandle = null, hv_circleIndices = null;
        HTuple hv_circleParameter = null, hv_Row = null, hv_Column = null;
        HTuple hv_UsedRow = null, hv_UsedColumn = null, hv_StartPhi = null;
        HTuple hv_EndPhi = null, hv_PointOrder = null;
        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_UsedEdges);
        HOperatorSet.GenEmptyObj(out ho_Contour);
        HOperatorSet.GenEmptyObj(out ho_ResultContours);
        HOperatorSet.GenEmptyObj(out ho_CrossCenter);
        HOperatorSet.GenEmptyObj(out ho_ModelContour);
        HOperatorSet.GenEmptyObj(out ho_Contours);
        try
        {
            HOperatorSet.CreateMetrologyModel(out hv_MetrologyHandle);
            HOperatorSet.AddMetrologyObjectGeneric(hv_MetrologyHandle, "circle", ((hv_InitialRow.TupleConcat(
                hv_InitialColumn))).TupleConcat(hv_InitialRadius), hv_Length, 5, 1, hv_Measure_Threshold,
                new HTuple(), new HTuple(), out hv_circleIndices);
            ho_ModelContour.Dispose();
            HOperatorSet.GetMetrologyObjectModelContour(out ho_ModelContour, hv_MetrologyHandle,
                "all", 1.5);
            //第一個點或最後一個點
            HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle, hv_circleIndices,
                "measure_select", hv_MeasureSelect);
            HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle, hv_circleIndices,
                "min_score", 0.2);
            HOperatorSet.ApplyMetrologyModel(ho_Image, hv_MetrologyHandle);
            HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, hv_circleIndices,
                "all", "result_type", "all_param", out hv_circleParameter);

            //白找黑('negative')或黑找白('positive')
            ho_Contour.Dispose();
            HOperatorSet.GetMetrologyObjectMeasures(out ho_Contour, hv_MetrologyHandle,
                "all", hv_MeasureTransition, out hv_Row, out hv_Column);
            ho_Contours.Dispose();
            HOperatorSet.GetMetrologyObjectResultContour(out ho_Contours, hv_MetrologyHandle,
                "all", "all", 1.5);
            HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, "all", "all", "used_edges",
                "row", out hv_UsedRow);
            HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, "all", "all", "used_edges",
                "column", out hv_UsedColumn);
            ho_UsedEdges.Dispose();
            HOperatorSet.GenCrossContourXld(out ho_UsedEdges, hv_UsedRow, hv_UsedColumn,
                10, (new HTuple(45)).TupleRad());
            ho_ResultContours.Dispose();
            HOperatorSet.GetMetrologyObjectResultContour(out ho_ResultContours, hv_MetrologyHandle,
                "all", "all", 1.5);
            HOperatorSet.FitCircleContourXld(ho_ResultContours, "algebraic", -1, 0, 0,
                3, 2, out hv_ResultRow, out hv_ResultColumn, out hv_ResultRadius, out hv_StartPhi,
                out hv_EndPhi, out hv_PointOrder);
            ho_CrossCenter.Dispose();
            HOperatorSet.GenCrossContourXld(out ho_CrossCenter, hv_ResultRow, hv_ResultColumn, 50, 0);
            HOperatorSet.ClearMetrologyModel(hv_MetrologyHandle);
            ho_ModelContour.Dispose();
            ho_Contours.Dispose();
            return;
        }
        catch (HalconException HDevExpDefaultException)
        {
            HOperatorSet.ClearMetrologyModel(hv_MetrologyHandle);
            ho_ModelContour.Dispose();
            ho_Contours.Dispose();
            throw HDevExpDefaultException;
        }
    }
    public void gen_rectangle2_center(HObject ho_Image, out HObject ho_Contour, out HObject ho_UsedEdges,
      out HObject ho_ResultContours, HTuple hv_InitialRow, HTuple hv_InitialColumn,
      HTuple hv_InitialPhi, HTuple hv_InitialLength1, HTuple hv_InitialLength2, HTuple hv_MeasureLength,
      HTuple hv_MeasureThreshold, HTuple hv_MeasureTransition, HTuple hv_MeasureSelect,
      out HTuple hv_ResultRow, out HTuple hv_ResultColumn, out HTuple hv_ResultPhi,
      out HTuple hv_ResultLength1, out HTuple hv_ResultLength2)
    {




        // Local iconic variables 

        HObject ho_ModelContour, ho_CrossCenter, ho_Contours;

        // Local control variables 

        HTuple hv_MetrologyHandle = null, hv_rectangleIndices = null;
        HTuple hv_rectangle_param = null, hv_Row = null, hv_Column = null;
        HTuple hv_UsedRow = null, hv_UsedColumn = null, hv_PointOrder1 = null;
        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_Contour);
        HOperatorSet.GenEmptyObj(out ho_UsedEdges);
        HOperatorSet.GenEmptyObj(out ho_ResultContours);
        HOperatorSet.GenEmptyObj(out ho_ModelContour);
        HOperatorSet.GenEmptyObj(out ho_CrossCenter);
        HOperatorSet.GenEmptyObj(out ho_Contours);
        try
        {
            HOperatorSet.CreateMetrologyModel(out hv_MetrologyHandle);
            //創建方形索引區域
            HOperatorSet.AddMetrologyObjectGeneric(hv_MetrologyHandle, "rectangle2", ((((((hv_InitialRow.TupleConcat(
                hv_InitialColumn))).TupleConcat(hv_InitialPhi))).TupleConcat(hv_InitialLength1))).TupleConcat(
                hv_InitialLength2), hv_MeasureLength, 5, 1, hv_MeasureThreshold, new HTuple(),
                new HTuple(), out hv_rectangleIndices);
            ho_ModelContour.Dispose();
            HOperatorSet.GetMetrologyObjectModelContour(out ho_ModelContour, hv_MetrologyHandle,
                "all", 1.5);
            //第一個點或最後一個點
            HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle, hv_rectangleIndices,
                "measure_select", hv_MeasureSelect);
            HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle, hv_rectangleIndices,
                "min_score", 0.2);
            HOperatorSet.ApplyMetrologyModel(ho_Image, hv_MetrologyHandle);
            
            
            //白找黑('negative')或黑找白('positive')
            ho_Contour.Dispose();
            HOperatorSet.GetMetrologyObjectMeasures(out ho_Contour, hv_MetrologyHandle,
                "all", hv_MeasureTransition, out hv_Row, out hv_Column);
            ho_Contours.Dispose();
            HOperatorSet.GetMetrologyObjectResultContour(out ho_Contours, hv_MetrologyHandle,
                "all", "all", 1.5);
            HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, "all", "all", "used_edges",
                "row", out hv_UsedRow);
            HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, "all", "all", "used_edges",
                "column", out hv_UsedColumn);
            ho_UsedEdges.Dispose();
            HOperatorSet.GenCrossContourXld(out ho_UsedEdges, hv_UsedRow, hv_UsedColumn,
                10, (new HTuple(45)).TupleRad());
            ho_ResultContours.Dispose();
            HOperatorSet.GetMetrologyObjectResultContour(out ho_ResultContours, hv_MetrologyHandle,
                "all", "all", 1.5);
            HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, hv_rectangleIndices,
                "all", "result_type", "all_param", out hv_rectangle_param);
            ho_CrossCenter.Dispose();
            HOperatorSet.GenCrossContourXld(out ho_CrossCenter, hv_rectangle_param.TupleSelect(
                0), hv_rectangle_param.TupleSelect(1), 20, 0.785398);
            hv_ResultRow = hv_rectangle_param[0];
            hv_ResultColumn = hv_rectangle_param[1];
            hv_ResultPhi = hv_rectangle_param[2];
            hv_ResultLength1 = hv_rectangle_param[3];
            hv_ResultLength2 = hv_rectangle_param[4];

            //避免角度有0度/180度的問題
            if (hv_ResultPhi > 135 / Math.PI)
                hv_ResultPhi = hv_ResultPhi - Math.PI;
            else if (hv_ResultPhi < -45 / Math.PI)
                hv_ResultPhi = hv_ResultPhi + Math.PI;
            //HOperatorSet.FitRectangle2ContourXld(ho_ResultContours, "regression", -1, 0,
            //    0, 3, 2, out hv_ResultRow, out hv_ResultColumn, out hv_ResultPhi, out hv_ResultLength1,
            //    out hv_ResultLength2, out hv_PointOrder1);
            HOperatorSet.ClearMetrologyModel(hv_MetrologyHandle);
            ho_ModelContour.Dispose();
            ho_CrossCenter.Dispose();
            ho_Contours.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_ModelContour.Dispose();
            ho_CrossCenter.Dispose();
            ho_Contours.Dispose();

            throw HDevExpDefaultException;
        }
    }
    #endregion

    public void Clear_Template()
    {
        try
        {
            if (hv_sample_NCC_ModelID != null)
            {
                HOperatorSet.ClearNccModel(hv_sample_NCC_ModelID);
            }
            if (hv_empty_NCC_ModelID != null)
            {
                HOperatorSet.ClearNccModel(hv_empty_NCC_ModelID);
            }
        }
        catch
        {
        }
    }
    public int Load_Template(System.String ncc_filename)
    {
        //Get template information
        try
        {
            HOperatorSet.ReadNccModel(ncc_filename, out hv_sample_NCC_ModelID);
            
        }
        catch (HalconException except)
        {
            return -1;
        }
        HObject ho_model_region;
        HTuple hv_dummy, hv_expected_length1, hv_expected_length2;
        HOperatorSet.GenEmptyObj(out ho_model_region);
        ho_model_region.Dispose();
        HOperatorSet.GetNccModelRegion(out ho_model_region, hv_sample_NCC_ModelID);
        HOperatorSet.SmallestRectangle2(ho_model_region, out hv_dummy, out hv_dummy,
            out hv_dummy, out hv_expected_length1, out hv_expected_length2);
        parameter_set["expected_length1"] = hv_expected_length1.D;
        parameter_set["expected_length2"] = hv_expected_length2.D;
        parameter_set["expected_fringe_radius"] = hv_expected_length1.D * 416.0 / 500.0;
        ho_model_region.Dispose();
        template_ready = true;
        return 0;
    }
    public Processor()
    {
        HOperatorSet.ReadNccModel("Module/empty_model", out hv_empty_NCC_ModelID);
        param_mux = new Mutex();
        parameter_set = new Dictionary<string, double>();
        parameter_set.Add("thresh_offset", 0.0);
        parameter_set.Add("angle_range", 15);
        parameter_set.Add("expected_holder_radius", 500);//預期的固定環半徑
        parameter_set.Add("ignore_radius", 350);
        parameter_set.Add("glue_min_area", 100);
        parameter_set.Add("spot_threshold", 20);
        parameter_set.Add("red_cyan_radius", 498);
        parameter_set.Add("yellow_red_radius", 442);
        parameter_set.Add("yellow_inner_radius", 442);
        parameter_set.Add("expected_length1", 0);
        parameter_set.Add("expected_length2", 0);
        parameter_set.Add("inside_holder_max_area", 5);
        parameter_set.Add("leakage_gray_offset", 5);
        parameter_set.Add("scar_thresh_offset", 0);
        parameter_set.Add("scar_outer_radius", 350);
        parameter_set.Add("scar_inner_radius", 300);
    }
    public System.String Query_Error_Code_Detail(int errorCode, out string errLog)
    {
        System.String errorDescript;
        switch (errorCode)
        {
            case 0:
                errLog = "Normal,";  //存log
                errorDescript = "正常,";    //视觉界面显示
                break;
            case -1:
                errLog = "Miss";  
                errorDescript = "Miss";  
                break;
            case -2:
                errLog = "The program failed to locate the product rectangular area,";
                errorDescript = "程序无法定位产品矩形区域,"; 
                break;
            case -3:
                errLog = "The program failed to find holder(edge black circle),"; 
                errorDescript = "程序找不到holder(边缘黑圈),"; 
                break;
            case -4:
                errLog = "Sample obviously abnormal,";
                errorDescript = "样本明显异常,";
                break;
            case -5:
                errLog = "Particle abnormal,"; 
                errorDescript = "Particle 异常,";
                break;
            case -6:
                errLog = "LensBarcode abnormal,";
                errorDescript = "LensBarcode掃碼異常";
                break;
            case -7:
                errLog = "Lens Fracture,";
                errorDescript = "鏡片破裂";
                break;
            case -998:
                errLog = "Templates have not been loaded or built,";
                errorDescript = "模板尚未加载或构建,"; 
                break;
            default:
                errLog = "For unknown reasons, please contact image processing personnel,"; 
                errorDescript = "未知原因,请联络影像处理人员,";
                break;
        }
        return errorDescript;
    }
    public double Query_Parameter(System.String parameter_name)
    {
        if (!parameter_set.ContainsKey(parameter_name))
        {
            throw new System.Exception("Parameter name is incorrect, please check it.");
        }
        return parameter_set[parameter_name];
    }
    // Main procedure 
    #region
    //(opened-parameter)
    ////param-1//
    //hv_high_thresh
    //Name: 边缘反射区域高阀值
    //Tooltip: 一个区域要能够被视为边缘反射区必须起吗有点的灰阶值高于此数值
    ////param-2//
    //hv_low_thresh
    //Name: 边缘反射区域低阀值
    //Tooltip: 边缘反射区每点的灰阶值皆必然高于此数值
    #endregion
    //high_thresh=250
    //low_thresh==240
    public int CreateTemplate_Auto(HObject ho_Image, int threshold, int angle_range,
        System.String ncc_filename, out HObject template_rect)
    {
        HOperatorSet.GenEmptyRegion(out template_rect);
        if (threshold > 255 || threshold < 0)
            return -1;
        // Stack for temporary objects 
        HObject[] OTemp = new HObject[20];

        // Local iconic variables 
        HObject ho_Image_GrayDilated;
        HObject ho_region255, ho_region255_complementary;
        HObject ho_region255_ = null, ho_region255_filled = null, ho_region255_hole = null;
        HObject ho_sample_region, ho_rectangle = null, ho_ImageReduced = null;

        // Local control variables 
        HTuple hv_thresh = threshold;
        HTuple hv_region255_count = null;
        HTuple hv_j = null, hv_areas = new HTuple(), hv_Row = new HTuple();
        HTuple hv_Column = new HTuple(), hv_sorted_index = new HTuple();
        HTuple hv_Number = null, hv_center_row = new HTuple();
        HTuple hv_center_col = new HTuple(), hv_Phi = new HTuple();
        HTuple hv_length1 = new HTuple(), hv_length2 = new HTuple();
        HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
        HTuple hv_MetrologyHandle = new HTuple(), hv_Index = new HTuple();
        HTuple hv_Parameter = new HTuple(), hv_ModelID = new HTuple();
        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_region255);
        HOperatorSet.GenEmptyObj(out ho_region255_complementary);
        HOperatorSet.GenEmptyObj(out ho_region255_);
        HOperatorSet.GenEmptyObj(out ho_region255_filled);
        HOperatorSet.GenEmptyObj(out ho_region255_hole);
        HOperatorSet.GenEmptyObj(out ho_sample_region);
        HOperatorSet.GenEmptyObj(out ho_rectangle);
        HOperatorSet.GenEmptyObj(out ho_ImageReduced);
        HOperatorSet.GenEmptyObj(out ho_Image_GrayDilated);
        //*******////////Create the template of the sample//////////***
        //---Purpose---
        //Create the sample correlation model template***

        //---Implementation----
        //1. This method relys on the very light area reflected by the edge of the sample to give a rough position and oriention of the sample
        //2. With the rough positioning, the program then uses Metrology Model to get accurate region of the model
        //---Note---

        ho_region255.Dispose();
        HOperatorSet.GrayDilationRect(ho_Image, out ho_Image_GrayDilated, 5, 5);
        HOperatorSet.Threshold(ho_Image_GrayDilated, out ho_region255, hv_thresh, 255);
        {
            HObject ExpTmpOutVar_0;
            HOperatorSet.RemoveNoiseRegion(ho_region255, out ExpTmpOutVar_0, "n_48");
            ho_region255.Dispose();
            ho_region255 = ExpTmpOutVar_0;
        }
        {
            HObject ExpTmpOutVar_0;
            HOperatorSet.Connection(ho_region255, out ExpTmpOutVar_0);
            ho_region255.Dispose();
            ho_region255 = ExpTmpOutVar_0;
        }
        HOperatorSet.CountObj(ho_region255, out hv_region255_count);
        ho_region255_complementary.Dispose();
        HOperatorSet.GenEmptyObj(out ho_region255_complementary);
        HTuple end_val29 = hv_region255_count;
        HTuple step_val29 = 1;
        for (hv_j = 1; hv_j.Continue(end_val29, step_val29); hv_j = hv_j.TupleAdd(step_val29))
        {
            ho_region255_.Dispose();
            HOperatorSet.SelectObj(ho_region255, out ho_region255_, hv_j);
            ho_region255_filled.Dispose();
            HOperatorSet.FillUp(ho_region255_, out ho_region255_filled);
            ho_region255_hole.Dispose();
            HOperatorSet.Difference(ho_region255_filled, ho_region255_, out ho_region255_hole
                );
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.Connection(ho_region255_hole, out ExpTmpOutVar_0);
                ho_region255_hole.Dispose();
                ho_region255_hole = ExpTmpOutVar_0;
            }
            HOperatorSet.AreaCenter(ho_region255_hole, out hv_areas, out hv_Row, out hv_Column);
            HOperatorSet.TupleSortIndex(-hv_areas, out hv_sorted_index);
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.SelectObj(ho_region255_hole, out ExpTmpOutVar_0, (hv_sorted_index.TupleSelect(
                    0)) + 1);
                ho_region255_hole.Dispose();
                ho_region255_hole = ExpTmpOutVar_0;
            }
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.ConcatObj(ho_region255_complementary, ho_region255_hole, out ExpTmpOutVar_0
                    );
                ho_region255_complementary.Dispose();
                ho_region255_complementary = ExpTmpOutVar_0;
            }
        }
        ho_sample_region.Dispose();
        HOperatorSet.SelectShape(ho_region255_complementary, out ho_sample_region, (new HTuple("area")).TupleConcat(
            "rectangularity"), "and", (new HTuple(800 * 800)).TupleConcat(0.5), (new HTuple(1200 * 1200)).TupleConcat(
            1));
        int result = -1;
        HOperatorSet.CountObj(ho_sample_region, out hv_Number);
        if ((int)(new HTuple(hv_Number.TupleEqual(1))) != 0)
        {
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.OpeningCircle(ho_sample_region, out ExpTmpOutVar_0, 7.5);
                ho_sample_region.Dispose();
                ho_sample_region = ExpTmpOutVar_0;
            }
            HOperatorSet.SmallestRectangle2(ho_sample_region, out hv_center_row, out hv_center_col,
                out hv_Phi, out hv_length1, out hv_length2);
            HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
            HOperatorSet.CreateMetrologyModel(out hv_MetrologyHandle);
            HOperatorSet.SetMetrologyModelImageSize(hv_MetrologyHandle, hv_Width, hv_Height);
            HOperatorSet.AddMetrologyObjectRectangle2Measure(hv_MetrologyHandle, hv_center_row,
                hv_center_col, hv_Phi, hv_length1, hv_length2, 20, 5, 1, 30, "measure_transition",
                "positive", out hv_Index);
            HOperatorSet.ApplyMetrologyModel(ho_Image, hv_MetrologyHandle);
            HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, hv_Index, "all",
                "result_type", "all_param", out hv_Parameter);
            ho_rectangle.Dispose();
            if (hv_Parameter.Length != 0)
            {
                HOperatorSet.GenRectangle2(out ho_rectangle, hv_Parameter.TupleSelect(0), hv_Parameter.TupleSelect(
                1), hv_Parameter.TupleSelect(2), hv_Parameter.TupleSelect(3), hv_Parameter.TupleSelect(
                4));
                template_ready = true;
                parameter_set["expected_length1"] = hv_Parameter.TupleSelect(3);
                parameter_set["expected_length2"] = hv_Parameter.TupleSelect(4);
                HOperatorSet.CopyObj(ho_rectangle, out template_rect, 1, -1);
                ho_ImageReduced.Dispose();
                HOperatorSet.ReduceDomain(ho_Image, ho_rectangle, out ho_ImageReduced);
                HOperatorSet.CreateNccModel(ho_ImageReduced, "auto", -((new HTuple(angle_range)).TupleRad()
                    ), 2*(new HTuple(angle_range)).TupleRad(), "auto", "use_polarity", out hv_ModelID);
                HOperatorSet.WriteNccModel(hv_ModelID, ncc_filename);
                this.hv_sample_NCC_ModelID = hv_ModelID;
                result = 0;
            }
        }
        ho_Image_GrayDilated.Dispose();
        ho_region255.Dispose();
        ho_region255_complementary.Dispose();
        ho_region255_.Dispose();
        ho_region255_filled.Dispose();
        ho_region255_hole.Dispose();
        ho_sample_region.Dispose();
        ho_rectangle.Dispose();
        ho_ImageReduced.Dispose();
        return result;
    }
    public int CreateTemplate_Manual(HObject ho_Image, HTuple rect_row, HTuple rect_col, HTuple rect_phi,
        HTuple rect_length1, HTuple rect_length2, int angle_range, System.String ncc_filename, out HObject template_rect)
    {
        HOperatorSet.GenEmptyRegion(out template_rect);
        // Stack for temporary objects 
        HObject[] OTemp = new HObject[20];

        // Local iconic variables 
        HObject ho_sample_region, ho_rectangle = null, ho_ImageReduced = null;

        // Local control variables 
        HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
        HTuple hv_MetrologyHandle = new HTuple(), hv_Index = new HTuple();
        HTuple hv_Parameter = new HTuple(), hv_ModelID = new HTuple();
        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_sample_region);
        HOperatorSet.GenEmptyObj(out ho_rectangle);
        HOperatorSet.GenEmptyObj(out ho_ImageReduced);
        //*******////////Create the template of the sample//////////***
        //---Purpose---
        //Create the sample correlation model template***

        //---Implementation----
        //1. Rectangle2 is drew manually.
        //2. With the rough positioning, the program then uses Metrology Model to get accurate region of the model
        //---Note---


        HObject ExpTmpOutVar_0;
        HOperatorSet.OpeningCircle(ho_sample_region, out ExpTmpOutVar_0, 7.5);
        ho_sample_region.Dispose();
        ho_sample_region = ExpTmpOutVar_0;

        HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
        HOperatorSet.CreateMetrologyModel(out hv_MetrologyHandle);
        HOperatorSet.SetMetrologyModelImageSize(hv_MetrologyHandle, hv_Width, hv_Height);
        HOperatorSet.AddMetrologyObjectRectangle2Measure(hv_MetrologyHandle, rect_row,
            rect_col, rect_phi, rect_length1, rect_length2, 20, 5, 1, 30, "measure_transition",
            "positive", out hv_Index);
        HOperatorSet.ApplyMetrologyModel(ho_Image, hv_MetrologyHandle);
        HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, hv_Index, "all",
            "result_type", "all_param", out hv_Parameter);
        ho_rectangle.Dispose();
        HOperatorSet.GenRectangle2(out ho_rectangle, hv_Parameter.TupleSelect(0), hv_Parameter.TupleSelect(
            1), hv_Parameter.TupleSelect(2), hv_Parameter.TupleSelect(3), hv_Parameter.TupleSelect(
            4));
        int result = -1;
        if (hv_Parameter.Length != 0)
        {
            template_ready = true;
            parameter_set["expected_length1"] = hv_Parameter.TupleSelect(3);
            parameter_set["expected_length2"] = hv_Parameter.TupleSelect(4);
            HOperatorSet.CopyObj(ho_rectangle, out template_rect, 1, -1);
            ho_ImageReduced.Dispose();
            HOperatorSet.ReduceDomain(ho_Image, ho_rectangle, out ho_ImageReduced);
            HOperatorSet.CreateNccModel(ho_ImageReduced, "auto", -((new HTuple(angle_range)).TupleRad()
                ), (new HTuple(angle_range)).TupleRad(), "auto", "use_polarity", out hv_ModelID);
            HOperatorSet.WriteNccModel(hv_ModelID, ncc_filename);
            this.hv_sample_NCC_ModelID = hv_ModelID;
            result = 0;
        }
        ho_sample_region.Dispose();
        ho_rectangle.Dispose();
        ho_ImageReduced.Dispose();
        return result;
    }
    // Procedures  
    private void My_Fillup_Intensity(HObject ho_srcImage, HObject ho_region, out HObject ho_filled_region,
        HTuple hv_area_thresh, HTuple hv_intensity_thresh)
    {
        // Stack for temporary objects 
        HObject[] OTemp = new HObject[20];

        // Local iconic variables 

        HObject ho_region_filled, ho_inverted_region;
        HObject ho_added_region;

        // Local control variables 

        HTuple hv_area = null, hv_rows = null, hv_cols = null;
        HTuple hv_gray_mean = null, hv_dummy = null, hv_large_area_mask = null;
        HTuple hv_median_dark_area_mask = null;
        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_filled_region);
        HOperatorSet.GenEmptyObj(out ho_region_filled);
        HOperatorSet.GenEmptyObj(out ho_inverted_region);
        HOperatorSet.GenEmptyObj(out ho_added_region);
        try
        {
            //---Purpose---
            //*Remove small holes in region**
            //---Implementation----
            //1. Fill up the region and use difference to get the holes
            //2. For holes whose area is too small
            ho_region_filled.Dispose();
            HOperatorSet.FillUp(ho_region, out ho_region_filled);
            ho_inverted_region.Dispose();
            HOperatorSet.Difference(ho_region_filled, ho_region, out ho_inverted_region
                );
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.Connection(ho_inverted_region, out ExpTmpOutVar_0);
                ho_inverted_region.Dispose();
                ho_inverted_region = ExpTmpOutVar_0;
            }
            HOperatorSet.AreaCenter(ho_inverted_region, out hv_area, out hv_rows, out hv_cols);
            if (hv_area.Length == 0)
            {
                HOperatorSet.CopyObj(ho_region, out ho_region_filled, 0, -1);
                return;
            }
            HOperatorSet.Intensity(ho_inverted_region, ho_srcImage, out hv_gray_mean, out hv_dummy);
            hv_large_area_mask = hv_area.TupleLessEqualElem(hv_area_thresh);
            hv_median_dark_area_mask = ((hv_area.TupleLessEqualElem(3 * hv_area_thresh))).TupleAnd(
                hv_gray_mean.TupleLessEqualElem(hv_intensity_thresh));
            ho_added_region.Dispose();
            select_mask_obj(ho_inverted_region, out ho_added_region, hv_large_area_mask.TupleOr(
                hv_median_dark_area_mask));
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.Union1(ho_added_region, out ExpTmpOutVar_0);
                ho_added_region.Dispose();
                ho_added_region = ExpTmpOutVar_0;
            }
            ho_filled_region.Dispose();
            HOperatorSet.Union2(ho_region, ho_added_region, out ho_filled_region);
            ho_region_filled.Dispose();
            ho_inverted_region.Dispose();
            ho_added_region.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_region_filled.Dispose();
            ho_inverted_region.Dispose();
            ho_added_region.Dispose();

            throw HDevExpDefaultException;
        }
    }

    private void Ostu_Threshold(HTuple hv_histogram, HTuple hv_probability_threshold,
        HTuple hv_grayvalue_threshold, out HTuple hv_thresh)
    {
        // Local iconic variables 

        // Local control variables 

        HTuple hv_selected_thresh = null, hv_max_variance = null;
        HTuple hv_gray_values = null, hv_pixel_count = null, hv_suppress_value = null;
        HTuple hv_suppress_mask = null, hv_histogram_suppressed = null;
        HTuple hv_i = null, hv_pcb = new HTuple(), hv_pcf = new HTuple();
        HTuple hv_Wb = new HTuple(), hv_Wf = new HTuple(), hv_grayvalue_sum_b = new HTuple();
        HTuple hv_mean_grayVal_b = new HTuple(), hv_grayvalue_sum_f = new HTuple();
        HTuple hv_mean_grayVal_f = new HTuple(), hv_variance = new HTuple();
        HTuple hv_histogram_COPY_INP_TMP = hv_histogram.Clone();

        // Initialize local and output iconic variables 
        //*******////////Separate bimodal histogram with a single threhold//////////***
        //---Purpose---
        //Decide the gray value which will separate the histogram into foregound and background with max variance***
        //---Implementation----
        //1. Overall this program is exactly the same as Ostu's, which finds the gray value that will make two clusters of the histogram
        //have maximum variance
        //2. In addition  I ignore the part of the histogram where gray value are above grayvalue_threshold.
        //3. Also I ignore part of the histogram where the probability is below probability_threshold
        //---Note---
        //>>>>>>>>>>>>>>>Parameter setting>>>>>>>>>>>>>>>
        //(closed)
        ////param-1//
        //grayvalue_threshold
        //Name: 灰阶忽略阈值
        //Tooltip: histogram当中灰阶高于此数值的都会被忽略不计, 也就是归零
        ////param-1//
        //probability_threshold
        //Name: 机率忽略阈值
        //Tooltip: histogram当中机率低于此数值的都会被忽略不计, 也就是归零
        //(opened-parameter)
        //<<<<<<<<<<<<<<Parameter setting<<<<<<<<<<<<<<<<<
        hv_selected_thresh = -1;
        hv_max_variance = -1;
        HOperatorSet.TupleGenSequence(0, 255, 1, out hv_gray_values);
        if (hv_histogram_COPY_INP_TMP == null)
            hv_histogram_COPY_INP_TMP = new HTuple();
        hv_histogram_COPY_INP_TMP[HTuple.TupleGenSequence(hv_grayvalue_threshold, 255, 1)] = 0;
        hv_histogram_COPY_INP_TMP = hv_histogram_COPY_INP_TMP + 0.0;
        HOperatorSet.TupleSum(hv_histogram_COPY_INP_TMP, out hv_pixel_count);
        hv_suppress_value = hv_pixel_count * hv_probability_threshold;
        hv_suppress_mask = hv_histogram_COPY_INP_TMP.TupleGreaterElem(hv_suppress_value);
        HOperatorSet.TupleMult(hv_histogram_COPY_INP_TMP, hv_suppress_mask, out hv_histogram_suppressed);
        for (hv_i = 0; (int)hv_i <= 255; hv_i = (int)hv_i + 1)
        {
            HOperatorSet.TupleSum(hv_histogram_suppressed.TupleSelectRange(0, hv_i), out hv_pcb);
            HOperatorSet.TupleSum(hv_histogram_suppressed.TupleSelectRange(hv_i, 255), out hv_pcf);
            hv_Wb = (hv_pcb + 0.0) / hv_pixel_count;
            hv_Wf = (hv_pcf + 0.0) / hv_pixel_count;
            if ((int)((new HTuple(hv_Wb.TupleEqual(0))).TupleOr(new HTuple(hv_Wf.TupleEqual(
                0)))) != 0)
            {
                continue;
            }
            HOperatorSet.TupleMult(hv_histogram_suppressed.TupleSelectRange(0, hv_i), hv_gray_values.TupleSelectRange(
                0, hv_i), out hv_grayvalue_sum_b);
            HOperatorSet.TupleSum(hv_grayvalue_sum_b, out hv_grayvalue_sum_b);
            hv_mean_grayVal_b = hv_grayvalue_sum_b / hv_pcb;
            HOperatorSet.TupleMult(hv_histogram_suppressed.TupleSelectRange(hv_i, 255),
                hv_gray_values.TupleSelectRange(hv_i, 255), out hv_grayvalue_sum_f);
            HOperatorSet.TupleSum(hv_grayvalue_sum_f, out hv_grayvalue_sum_f);
            hv_mean_grayVal_f = hv_grayvalue_sum_f / hv_pcf;
            hv_variance = ((hv_Wb * hv_Wf) * (hv_mean_grayVal_f - hv_mean_grayVal_b)) * (hv_mean_grayVal_f - hv_mean_grayVal_b);
            if ((int)(new HTuple(hv_variance.TupleGreater(hv_max_variance))) != 0)
            {
                hv_max_variance = hv_variance.Clone();
                hv_selected_thresh = hv_i.Clone();
            }
        }
        hv_thresh = hv_selected_thresh.Clone();

        return;
    }

    // Chapter: Object / Manipulation
    // Short Description: Select elements from object arrays using a mask. 
    private void select_mask_obj(HObject ho_Objects, out HObject ho_SelectedObjects,
        HTuple hv_Mask)
    {
        // Local iconic variables 

        // Local control variables 

        HTuple hv_Number = null, hv_AllNumbers = null;
        HTuple hv_Indices = null;
        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_SelectedObjects);
        //select_mask_obj selects one or more single elements of the object array
        //Objects and returns them in SelectedObjects.
        //The elements of Mask determine if the corresponding elements of Objects are selected.
        //If the value is greater than 0, the corresponding element is selected.
        //
        //Check number of elements
        HOperatorSet.CountObj(ho_Objects, out hv_Number);
        if ((int)(new HTuple(hv_Number.TupleNotEqual(new HTuple(hv_Mask.TupleLength()
            )))) != 0)
        {
            throw new HalconException("Number of elements in Objects and Mask do not match.");
        }
        //
        //Check type of mask elements
        hv_AllNumbers = new HTuple((((((hv_Mask.TupleIsRealElem())).TupleSum()) + (((hv_Mask.TupleIsIntElem()
            )).TupleSum()))).TupleEqual(new HTuple(hv_Mask.TupleLength())));
        if ((int)((new HTuple(hv_AllNumbers.TupleNot())).TupleAnd(new HTuple(hv_Mask.TupleNotEqual(
            new HTuple())))) != 0)
        {
            throw new HalconException("Invalid type: Elements of Mask must be integer or real numbers.");
        }
        //
        //Use select_mask for tuples to generate a list of object indices.
        hv_Indices = (HTuple.TupleGenSequence(1, new HTuple(hv_Mask.TupleLength()), 1)).TupleSelectMask(
            hv_Mask);
        ho_SelectedObjects.Dispose();
        HOperatorSet.SelectObj(ho_Objects, out ho_SelectedObjects, hv_Indices);

        return;
    }

    private void Fit_Circle_Using_Points(HTuple hv_rows, HTuple hv_cols, out HTuple hv_circle_row,
        out HTuple hv_circle_col, out HTuple hv_circle_radius)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_p_count = null, hv_rows_mean = null;
        HTuple hv_cols_mean = null, hv_x = null, hv_y = null, hv_z = null;
        HTuple hv_Mxy = null, hv_Mxx = null, hv_Myy = null, hv_Mxz = null;
        HTuple hv_Myz = null, hv_Mzz = null, hv_Mz = null, hv_Cov_xy = null;
        HTuple hv_Mxz2 = null, hv_Myz2 = null, hv_A2 = null, hv_A1 = null;
        HTuple hv_A0 = null, hv_A22 = null, hv_epsilon = null;
        HTuple hv_y_new = null, hv_IterMax = null, hv_x_new = null;
        HTuple hv_ite = null, hv_y_old = new HTuple(), hv_Dy = new HTuple();
        HTuple hv_x_old = new HTuple(), hv_DET = null;
        // Initialize local and output iconic variables 
        hv_circle_row = -1;
        hv_circle_col = -1;
        hv_circle_radius = -1;
        if ((int)(new HTuple((new HTuple(hv_rows.TupleLength())).TupleNotEqual(new HTuple(hv_cols.TupleLength()
            )))) != 0)
        {
            throw new HalconException(new HTuple());
        }
        hv_p_count = new HTuple(hv_rows.TupleLength());
        if ((int)(new HTuple(hv_p_count.TupleLess(10))) != 0)
        {

            return;
        }
        HOperatorSet.TupleMean(hv_rows, out hv_rows_mean);
        HOperatorSet.TupleMean(hv_cols, out hv_cols_mean);
        hv_x = hv_rows - hv_rows_mean;
        hv_y = hv_cols - hv_cols_mean;
        hv_z = (hv_x * hv_x) + (hv_y * hv_y);
        HOperatorSet.TupleSum(hv_x * hv_y, out hv_Mxy);
        HOperatorSet.TupleSum(hv_x * hv_x, out hv_Mxx);
        HOperatorSet.TupleSum(hv_y * hv_y, out hv_Myy);
        HOperatorSet.TupleSum(hv_x * hv_z, out hv_Mxz);
        HOperatorSet.TupleSum(hv_y * hv_z, out hv_Myz);
        HOperatorSet.TupleSum(hv_z * hv_z, out hv_Mzz);
        hv_Mxy = hv_Mxy / hv_p_count;
        hv_Mxx = hv_Mxx / hv_p_count;
        hv_Myy = hv_Myy / hv_p_count;
        hv_Mxz = hv_Mxz / hv_p_count;
        hv_Myz = hv_Myz / hv_p_count;
        hv_Mzz = hv_Mzz / hv_p_count;

        hv_Mz = hv_Mxx + hv_Myy;
        hv_Cov_xy = (hv_Mxx * hv_Myy) - (hv_Mxy * hv_Mxy);
        hv_Mxz2 = hv_Mxz * hv_Mxz;
        hv_Myz2 = hv_Myz * hv_Myz;

        hv_A2 = ((4 * hv_Cov_xy) - ((3 * hv_Mz) * hv_Mz)) - hv_Mzz;
        hv_A1 = ((((hv_Mzz * hv_Mz) + ((4 * hv_Cov_xy) * hv_Mz)) - hv_Mxz2) - hv_Myz2) - ((hv_Mz * hv_Mz) * hv_Mz);
        hv_A0 = ((((hv_Mxz2 * hv_Myy) + (hv_Myz2 * hv_Mxx)) - (hv_Mzz * hv_Cov_xy)) - (((2 * hv_Mxz) * hv_Myz) * hv_Mxy)) + ((hv_Mz * hv_Mz) * hv_Cov_xy);
        hv_A22 = hv_A2 + hv_A2;

        hv_epsilon = 1e-12;
        hv_y_new = 1e+20;
        hv_IterMax = 50;
        hv_x_new = 0;

        HTuple end_val43 = hv_IterMax - 1;
        HTuple step_val43 = 1;
        for (hv_ite = 0; hv_ite.Continue(end_val43, step_val43); hv_ite = hv_ite.TupleAdd(step_val43))
        {
            hv_y_old = hv_y_new.Clone();
            hv_y_new = hv_A0 + (hv_x_new * (hv_A1 + (hv_x_new * (hv_A2 + ((4.0 * hv_x_new) * hv_x_new)))));
            //*Newstons Method goes wrong direction
            if ((int)(new HTuple(((hv_y_new.TupleAbs())).TupleGreater(hv_y_old.TupleAbs()
                ))) != 0)
            {
                hv_x_new = 0;
                break;
            }
            hv_Dy = hv_A1 + (hv_x_new * (hv_A22 + ((16 * hv_x_new) * hv_x_new)));
            hv_x_old = hv_x_new.Clone();
            hv_x_new = hv_x_old - (hv_y_new / hv_Dy);
            if ((int)(new HTuple(hv_x_new.TupleEqual(0))) != 0)
            {
                continue;
            }
            if ((int)(new HTuple((((((hv_x_new - hv_x_old) / hv_x_new)).TupleAbs())).TupleLess(
                hv_epsilon))) != 0)
            {
                break;
            }
            if ((int)(new HTuple(hv_x_new.TupleLess(0))) != 0)
            {
                hv_x_new = 0;
            }
        }

        hv_DET = ((hv_x_new * hv_x_new) - (hv_x_new * hv_Mz)) + hv_Cov_xy;
        hv_circle_row = (((hv_Mxz * (hv_Myy - hv_x_new)) - (hv_Myz * hv_Mxy)) / hv_DET) / 2;
        hv_circle_col = (((hv_Myz * (hv_Mxx - hv_x_new)) - (hv_Mxz * hv_Mxy)) / hv_DET) / 2;
        hv_circle_radius = (((hv_circle_row * hv_circle_row) + (hv_circle_col * hv_circle_col)) + hv_Mz) + (2 * hv_x_new);
        HOperatorSet.TupleSqrt(hv_circle_radius, out hv_circle_radius);
        hv_circle_row = hv_circle_row + hv_rows_mean;
        hv_circle_col = hv_circle_col + hv_cols_mean;

        return;
    }
    private void My_Fillup(HObject ho_region, out HObject ho_filled_region, HTuple hv_area_thresh)
    {
        // Stack for temporary objects 
        HObject[] OTemp = new HObject[20];

        // Local iconic variables 

        HObject ho_region_filled, ho_inverted_region;
        HObject ho_added_region;
        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_filled_region);
        HOperatorSet.GenEmptyObj(out ho_region_filled);
        HOperatorSet.GenEmptyObj(out ho_inverted_region);
        HOperatorSet.GenEmptyObj(out ho_added_region);
        try
        {
            ho_region_filled.Dispose();
            HOperatorSet.FillUp(ho_region, out ho_region_filled);
            ho_inverted_region.Dispose();
            HOperatorSet.Difference(ho_region_filled, ho_region, out ho_inverted_region
                );
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.Connection(ho_inverted_region, out ExpTmpOutVar_0);
                ho_inverted_region.Dispose();
                ho_inverted_region = ExpTmpOutVar_0;
            }
            ho_added_region.Dispose();
            HOperatorSet.SelectShape(ho_inverted_region, out ho_added_region, "area", "and",
                0, hv_area_thresh);
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.Union1(ho_added_region, out ExpTmpOutVar_0);
                ho_added_region.Dispose();
                ho_added_region = ExpTmpOutVar_0;
            }
            ho_filled_region.Dispose();
            HOperatorSet.Union2(ho_region, ho_added_region, out ho_filled_region);
            ho_region_filled.Dispose();
            ho_inverted_region.Dispose();
            ho_added_region.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_region_filled.Dispose();
            ho_inverted_region.Dispose();
            ho_added_region.Dispose();

            throw HDevExpDefaultException;
        }
    }

    private void RANSAC_FIT_CIRCLE(HObject ho_srcImage, HTuple hv_point_rows, HTuple hv_point_cols,
     HTuple hv_max_iteration, HTuple hv_expected_error, out HTuple hv_circle_row,
     out HTuple hv_circle_col, out HTuple hv_circle_radius, out HTuple hv_mean_error)
    {




        // Local iconic variables 

        HObject ho_firstTryCircle = null;

        // Local control variables 

        HTuple hv_expected_outlier_ratio = null, hv_point_length = null;
        HTuple hv_expected_inlier_count = null, hv_selected_points_rows = null;
        HTuple hv_selected_points_cols = null, hv_min_mean_error = null;
        HTuple hv_ite = null, hv_random_indices = new HTuple();
        HTuple hv_sampled_rows = new HTuple(), hv_sampled_cols = new HTuple();
        HTuple hv_fit_row_first = new HTuple(), hv_fit_col_first = new HTuple();
        HTuple hv_fit_radius_first = new HTuple(), hv_row_distance = new HTuple();
        HTuple hv_col_distance = new HTuple(), hv_row_distance_power2 = new HTuple();
        HTuple hv_col_distance_power2 = new HTuple(), hv_distances = new HTuple();
        HTuple hv_radius_offset = new HTuple(), hv_radius_offset_sorted = new HTuple();
        HTuple hv_within_error_mask = new HTuple(), hv_within_error_rows = new HTuple();
        HTuple hv_within_error_cols = new HTuple(), hv_fit_row_snd = new HTuple();
        HTuple hv_fit_col_snd = new HTuple(), hv_fit_radius_snd = new HTuple();
        HTuple hv_mean_error_ = new HTuple(), hv_pre_min_mean_error = new HTuple();
        HTuple hv_expected_error_COPY_INP_TMP = hv_expected_error.Clone();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_firstTryCircle);
        hv_mean_error = new HTuple();
        try
        {
            //---Purpose---
            //Fit circle to points which may contain outliers*

            //---Implementation----
            //1. First randomly select points
            //2. Fit these points to get a circle information such as center and radius
            //3. With the center pinned down, select those points which are within the acceptable error,
            //and use these points to get a new circle.
            //4. Estimate the error of this new circle. If the new error is smaller, update the circle

            //---Note---
            //The sampling of circle points is evenly spaced.
            //>>>>>>>>>>>>>>>Parameter setting>>>>>>>>>>>>>>>
            //(closed)
            ////param-1//
            //Name: max_iteration
            //Tooltip: As the name suggest, it is the maixmum iteration that the for loop will go through. However
            //it may terminate earlier, if the error is within acceptable range.
            ////param-2//
            //Name: expected_error
            //Tooltip: This value indicate how far the poiints will deviate from the circle
            ////param-3//
            //Name: expected_outlier_ratio
            //Tooltip: This value indicate the proportion of expected outlier
            //(opened-parameter)
            //<<<<<<<<<<<<<<Parameter setting<<<<<<<<<<<<<<<<<
            hv_circle_row = -1;
            hv_circle_col = -1;
            hv_circle_radius = -1;
            hv_expected_outlier_ratio = 0.3;
            if ((int)(new HTuple((new HTuple(hv_point_rows.TupleLength())).TupleNotEqual(
                new HTuple(hv_point_cols.TupleLength())))) != 0)
            {
                ho_firstTryCircle.Dispose();

                return;
            }
            //gen_cross_contour_xld (Cross, point_rows, point_cols, 6, 0.785398)
            //A way to convert integer to float
            hv_expected_error_COPY_INP_TMP = hv_expected_error_COPY_INP_TMP + 0.0;
            HOperatorSet.TupleLength(hv_point_rows, out hv_point_length);
            if ((int)(new HTuple(hv_point_length.TupleLess(30))) != 0)
            {
                ho_firstTryCircle.Dispose();

                return;
            }
            HOperatorSet.TupleInt(hv_point_length * (1 - hv_expected_outlier_ratio), out hv_expected_inlier_count);
            hv_selected_points_rows = new HTuple();
            hv_selected_points_cols = new HTuple();
            hv_min_mean_error = 1e10;
            HTuple end_val44 = hv_max_iteration;
            HTuple step_val44 = 1;
            for (hv_ite = 1; hv_ite.Continue(end_val44, step_val44); hv_ite = hv_ite.TupleAdd(step_val44))
            {
                //(1)
                HOperatorSet.TupleRand(hv_expected_inlier_count, out hv_random_indices);
                HOperatorSet.TupleInt(hv_random_indices * hv_point_length, out hv_random_indices);
                hv_sampled_rows = hv_point_rows.TupleSelect(hv_random_indices);
                hv_sampled_cols = hv_point_cols.TupleSelect(hv_random_indices);
                //(2)
                Fit_Circle_Using_Points(hv_sampled_rows, hv_sampled_cols, out hv_fit_row_first,
                    out hv_fit_col_first, out hv_fit_radius_first);
                ho_firstTryCircle.Dispose();
                HOperatorSet.GenCircleContourXld(out ho_firstTryCircle, hv_fit_row_first,
                    hv_fit_col_first, hv_fit_radius_first, 0, 6.28318, "positive", 1);
                if ((int)(new HTuple(hv_fit_row_first.TupleEqual(-1))) != 0)
                {
                    continue;
                }
                //(3)
                hv_row_distance = hv_point_rows - hv_fit_row_first;
                hv_col_distance = hv_point_cols - hv_fit_col_first;
                HOperatorSet.TupleMult(hv_row_distance, hv_row_distance, out hv_row_distance_power2);
                HOperatorSet.TupleMult(hv_col_distance, hv_col_distance, out hv_col_distance_power2);
                HOperatorSet.TupleSqrt(hv_row_distance_power2 + hv_col_distance_power2, out hv_distances);
                HOperatorSet.TupleAbs(hv_distances - hv_fit_radius_first, out hv_radius_offset);
                HOperatorSet.TupleSort(hv_radius_offset, out hv_radius_offset_sorted);
                hv_within_error_mask = hv_radius_offset.TupleLessEqualElem(hv_radius_offset_sorted.TupleSelect(
                    (hv_expected_inlier_count * 5) / 6));
                HOperatorSet.TupleSelectMask(hv_point_rows, hv_within_error_mask, out hv_within_error_rows);
                HOperatorSet.TupleSelectMask(hv_point_cols, hv_within_error_mask, out hv_within_error_cols);
                if ((int)(new HTuple((new HTuple(hv_within_error_rows.TupleLength())).TupleLess(
                    hv_point_length * 0.3))) != 0)
                {
                    continue;
                }
                //Fit circle once again with those points that are within the acceptable error
                Fit_Circle_Using_Points(hv_within_error_rows, hv_within_error_cols, out hv_fit_row_snd,
                    out hv_fit_col_snd, out hv_fit_radius_snd);
                //(4)
                if ((int)(new HTuple((new HTuple(hv_within_error_rows.TupleLength())).TupleLess(
                    hv_radius_offset_sorted * 0.7))) != 0)
                {
                    continue;
                }
                hv_row_distance = hv_within_error_rows - hv_fit_row_snd;
                hv_col_distance = hv_within_error_cols - hv_fit_col_snd;
                HOperatorSet.TupleMult(hv_row_distance, hv_row_distance, out hv_row_distance_power2);
                HOperatorSet.TupleMult(hv_col_distance, hv_col_distance, out hv_col_distance_power2);
                HOperatorSet.TupleSqrt(hv_row_distance_power2 + hv_col_distance_power2, out hv_distances);
                HOperatorSet.TupleAbs(hv_distances - hv_fit_radius_first, out hv_radius_offset);
                HOperatorSet.TupleMean(hv_radius_offset, out hv_mean_error_);
                if ((int)(new HTuple(hv_mean_error_.TupleLess(hv_min_mean_error))) != 0)
                {
                    hv_pre_min_mean_error = hv_min_mean_error.Clone();
                    hv_min_mean_error = hv_mean_error_.Clone();
                    hv_mean_error = hv_mean_error_.Clone();
                    hv_selected_points_rows = hv_within_error_rows.Clone();
                    hv_selected_points_cols = hv_within_error_cols.Clone();
                    hv_circle_row = hv_fit_row_snd.Clone();
                    hv_circle_col = hv_fit_col_snd.Clone();
                    hv_circle_radius = hv_fit_radius_snd.Clone();
                }
                if ((int)(new HTuple((((((hv_pre_min_mean_error - hv_min_mean_error)).TupleAbs()
                    ) / hv_pre_min_mean_error)).TupleLess(0.05))) != 0)
                {
                    break;
                }
                //gen_circle_contour_xld (fitted_circle, circle_row, circle_col, circle_radius, 0, 6.28318, 'positive', 1)
                //gen_cross_contour_xld (withinError_crosses, within_error_rows, within_error_cols, 6, 0.785398)
                //gen_cross_contour_xld (sample_cross, sampled_rows, sampled_cols, 6, 0.785398)
                if (HDevWindowStack.IsOpen())
                {
                    //dev_display (srcImage)
                }
                if (HDevWindowStack.IsOpen())
                {
                    //dev_set_color ('red')
                }
                if (HDevWindowStack.IsOpen())
                {
                    //dev_display (firstTryCircle)
                }
                if (HDevWindowStack.IsOpen())
                {
                    //dev_set_color ('yellow')
                }
                if (HDevWindowStack.IsOpen())
                {
                    //dev_display (fitted_circle)
                }
                //stop ()
            }
            //gen_circle_contour_xld (fitted_circle, circle_row, circle_col, circle_radius, 0, 6.28318, 'positive', 1)
            ho_firstTryCircle.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_firstTryCircle.Dispose();

            throw HDevExpDefaultException;
        }
    }

    public int Process(HObject ho_srcImage, out HObject glue_region, out HObject leakage_region, out HObject spot_region,out HObject inside_scar_region, out Result result)
    {
        return Process_(1, ho_srcImage, out glue_region, out leakage_region, out spot_region,out inside_scar_region ,out result);
    }

    public int Process(HObject ho_srcImage, out HObject glue_region, out HObject leakage_region,out HObject inside_scar_region, out Result result)
    {
        HObject dummy_region;
        return Process_(0, ho_srcImage, out glue_region, out leakage_region, out dummy_region,out inside_scar_region, out result);
    }

    //mode: 0 ---> no spot region is returned
    //mode: 1 ---> spot region is returned
    private void Get_Region_Angle_Range(HObject ho_region, HTuple hv_center_row, HTuple hv_center_col,
    out HTuple hv_angle_range, out HTuple hv_mean_radiual_length)
    {
        // Local iconic variables 
        HObject ho_region_ = null;
        // Local control variables 
        HTuple hv_region_count = null, hv_i = null;
        HTuple hv_rows = new HTuple(), hv_cols = new HTuple();
        HTuple hv_vector_row = new HTuple(), hv_vector_col = new HTuple();
        HTuple hv_vector_angle = new HTuple(), hv_vector_angle_positive_mask = new HTuple();
        HTuple hv_vector_angle_positive = new HTuple(), hv_vector_angle_negative = new HTuple();
        HTuple hv_angle_postive_range = new HTuple(), hv_angle_negative_range = new HTuple();
        HTuple hv_angle_range_ = new HTuple(), hv_vector_row_square = new HTuple();
        HTuple hv_vector_col_square = new HTuple(), hv_vector_dist_square = new HTuple();
        HTuple hv_mean_dist_to_center = new HTuple(), hv_arc_length = new HTuple();
        HTuple hv_area = new HTuple(), hv_Row = new HTuple(), hv_Column = new HTuple();
        HTuple hv_mean_radiual_length_ = new HTuple();
        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_region_);
        try
        {
            //---Purpose---
            //*Determine if the angle range and mean_radial_length**

            //---Implementation----
            //1. Get all the pixel points of the region and calculate its angular coordinates
            //2. Determine the angle range from the angular coordiante of the each points. Note that
            //   specail care should be taken if the region has point near 3.14159 and -3.14159
            //3. The calculate of the mean radial distance is simple the area of the region divided by the arc length
            //   and the calculation of the arc length is the (mean distance)*(angle range)

            //>>>>>>>>>>>>>>>Parameter setting>>>>>>>>>>>>>>>
            //(closed)
            ////param-1//
            //(opened-parameter)
            //<<<<<<<<<<<<<<Parameter setting<<<<<<<<<<<<<<<<<
            HOperatorSet.CountObj(ho_region, out hv_region_count);
            HOperatorSet.TupleGenConst(hv_region_count, 0, out hv_angle_range);
            HOperatorSet.TupleGenConst(hv_region_count, 0, out hv_mean_radiual_length);
            HTuple end_val18 = hv_region_count - 1;
            HTuple step_val18 = 1;
            for (hv_i = 0; hv_i.Continue(end_val18, step_val18); hv_i = hv_i.TupleAdd(step_val18))
            {
                ho_region_.Dispose();
                HOperatorSet.SelectObj(ho_region, out ho_region_, hv_i + 1);
                //(1)
                HOperatorSet.GetRegionPoints(ho_region_, out hv_rows, out hv_cols);
                hv_vector_row = hv_rows - hv_center_row;
                hv_vector_col = hv_cols - hv_center_col;
                HOperatorSet.TupleAtan2(hv_vector_col, hv_vector_row, out hv_vector_angle);
                //(2)
                hv_vector_angle_positive_mask = hv_vector_angle.TupleGreaterEqualElem(0);
                HOperatorSet.TupleSelectMask(hv_vector_angle, hv_vector_angle_positive_mask,
                    out hv_vector_angle_positive);
                HOperatorSet.TupleSelectMask(hv_vector_angle, 1 - hv_vector_angle_positive_mask,
                    out hv_vector_angle_negative);
                HOperatorSet.TupleSort(hv_vector_angle_positive, out hv_vector_angle_positive);
                HOperatorSet.TupleSort(hv_vector_angle_negative, out hv_vector_angle_negative);
                hv_angle_postive_range = 0;
                hv_angle_negative_range = 0;
                if ((int)(new HTuple((new HTuple(hv_vector_angle_positive.TupleLength())).TupleGreaterEqual(
                    2))) != 0)
                {
                    hv_angle_postive_range = (hv_vector_angle_positive.TupleSelect((new HTuple(hv_vector_angle_positive.TupleLength()
                        )) - 1)) - (hv_vector_angle_positive.TupleSelect(0));
                }
                if ((int)(new HTuple((new HTuple(hv_vector_angle_negative.TupleLength())).TupleGreaterEqual(
                    2))) != 0)
                {
                    hv_angle_negative_range = (hv_vector_angle_negative.TupleSelect((new HTuple(hv_vector_angle_negative.TupleLength()
                        )) - 1)) - (hv_vector_angle_negative.TupleSelect(0));
                }
                hv_angle_range_ = hv_angle_postive_range + hv_angle_negative_range;
                if (hv_angle_range == null)
                    hv_angle_range = new HTuple();
                hv_angle_range[hv_i] = hv_angle_range_;
                if ((int)(new HTuple(hv_angle_range_.TupleEqual(0))) != 0)
                {
                    if (hv_mean_radiual_length == null)
                        hv_mean_radiual_length = new HTuple();
                    hv_mean_radiual_length[hv_i] = 0;
                    continue;
                }
                //(3)
                HOperatorSet.TupleMult(hv_vector_row, hv_vector_row, out hv_vector_row_square);
                HOperatorSet.TupleMult(hv_vector_col, hv_vector_col, out hv_vector_col_square);
                HOperatorSet.TupleSqrt(hv_vector_row_square + hv_vector_col_square, out hv_vector_dist_square);
                HOperatorSet.TupleMean(hv_vector_dist_square, out hv_mean_dist_to_center);
                hv_arc_length = hv_mean_dist_to_center * hv_angle_range_;
                HOperatorSet.AreaCenter(ho_region_, out hv_area, out hv_Row, out hv_Column);
                hv_mean_radiual_length_ = (hv_area + 0.0) / (hv_arc_length + 0.0);
                if (hv_mean_radiual_length == null)
                    hv_mean_radiual_length = new HTuple();
                hv_mean_radiual_length[hv_i] = hv_mean_radiual_length_;
            }
            ho_region_.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_region_.Dispose();

            throw HDevExpDefaultException;
        }
    }

    private void Get_Region_Angle_Range(HObject ho_region, HObject ho_srcImage, HTuple hv_center_row,
      HTuple hv_center_col, HTuple hv_min_arc_length, HTuple hv_min_radial_width,
      out HTuple hv_pass_indices)
    {
        // Local iconic variables 

        HObject ho_region_ = null;

        // Local control variables 

        HTuple hv_region_count = null, hv_i = null;
        HTuple hv_rows = new HTuple(), hv_cols = new HTuple();
        HTuple hv_vector_row = new HTuple(), hv_vector_col = new HTuple();
        HTuple hv_vector_radian = new HTuple(), hv_vector_radian_positive_mask = new HTuple();
        HTuple hv_vector_radian_positive = new HTuple(), hv_vector_row_positive = new HTuple();
        HTuple hv_vector_col_positive = new HTuple(), hv_vector_radian_negative = new HTuple();
        HTuple hv_vector_row_negative = new HTuple(), hv_vector_col_negative = new HTuple();
        HTuple hv_vector_radian_positive_sort_index = new HTuple();
        HTuple hv_vector_radian_negative_sort_index = new HTuple();
        HTuple hv_radian_postive_range = new HTuple(), hv_radian_negative_range = new HTuple();
        HTuple hv_radian_range_ = new HTuple(), hv_radian_range = new HTuple();
        HTuple hv_vector_row_square = new HTuple(), hv_vector_col_square = new HTuple();
        HTuple hv_vector_dist_square = new HTuple(), hv_mean_dist_to_center = new HTuple();
        HTuple hv_radian_step = new HTuple(), hv_radian_all = new HTuple();
        HTuple hv_radian_seq = new HTuple(), hv_small_part_valid_flag = new HTuple();
        HTuple hv_arc_length = new HTuple(), hv_j = new HTuple();
        HTuple hv_within_angle_range_mask = new HTuple(), hv_small_part_area = new HTuple();
        HTuple hv_small_part_radial_length_ = new HTuple(), hv_count = new HTuple();
        HTuple hv_continuous_tuple = new HTuple(), hv_flag = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_region_);
        try
        {
            //---Purpose---
            //*Determine if the radian range and mean_radial_length**

            //---Implementation----
            //1. Get all the pixel points of the region and calculate its angular coordinates
            //2. Determine the radian range from the angular coordiante of the each points. Note that
            //   specail care should be taken if the region has point near 3.14159 and -3.14159
            //3. The calculate of the mean radial distance is simple the area of the region divided by the arc length
            //   and the calculation of the arc length is the (mean distance)*(radian range)

            //>>>>>>>>>>>>>>>Parameter setting>>>>>>>>>>>>>>>
            //(closed)
            ////param-1//
            //(opened-parameter)
            //<<<<<<<<<<<<<<Parameter setting<<<<<<<<<<<<<<<<<
            HOperatorSet.CountObj(ho_region, out hv_region_count);
            HOperatorSet.TupleGenConst(hv_region_count, 0, out hv_pass_indices);
            HTuple end_val17 = hv_region_count - 1;
            HTuple step_val17 = 1;
            for (hv_i = 0; hv_i.Continue(end_val17, step_val17); hv_i = hv_i.TupleAdd(step_val17))
            {
                ho_region_.Dispose();
                HOperatorSet.SelectObj(ho_region, out ho_region_, hv_i + 1);
                //(1)
                HOperatorSet.GetRegionPoints(ho_region_, out hv_rows, out hv_cols);
                hv_vector_row = hv_rows - hv_center_row;
                hv_vector_col = hv_cols - hv_center_col;
                HOperatorSet.TupleAtan2(hv_vector_col, hv_vector_row, out hv_vector_radian);
                //(2)
                hv_vector_radian_positive_mask = hv_vector_radian.TupleGreaterEqualElem(0);
                HOperatorSet.TupleSelectMask(hv_vector_radian, hv_vector_radian_positive_mask,
                    out hv_vector_radian_positive);
                HOperatorSet.TupleSelectMask(hv_vector_row, hv_vector_radian_positive_mask,
                    out hv_vector_row_positive);
                HOperatorSet.TupleSelectMask(hv_vector_col, hv_vector_radian_positive_mask,
                    out hv_vector_col_positive);
                HOperatorSet.TupleSelectMask(hv_vector_radian, 1 - hv_vector_radian_positive_mask,
                    out hv_vector_radian_negative);
                HOperatorSet.TupleSelectMask(hv_vector_row, 1 - hv_vector_radian_positive_mask,
                    out hv_vector_row_negative);
                HOperatorSet.TupleSelectMask(hv_vector_col, 1 - hv_vector_radian_positive_mask,
                    out hv_vector_col_negative);

                HOperatorSet.TupleSortIndex(hv_vector_radian_positive, out hv_vector_radian_positive_sort_index);
                HOperatorSet.TupleSortIndex(hv_vector_radian_negative, out hv_vector_radian_negative_sort_index);
                hv_vector_radian_positive = hv_vector_radian_positive.TupleSelect(hv_vector_radian_positive_sort_index);
                hv_vector_row_positive = hv_vector_row_positive.TupleSelect(hv_vector_radian_positive_sort_index);
                hv_vector_col_positive = hv_vector_col_positive.TupleSelect(hv_vector_radian_positive_sort_index);
                hv_vector_radian_negative = hv_vector_radian_negative.TupleSelect(hv_vector_radian_negative_sort_index);
                hv_vector_row_negative = hv_vector_row_negative.TupleSelect(hv_vector_radian_negative_sort_index);
                hv_vector_col_negative = hv_vector_col_negative.TupleSelect(hv_vector_radian_negative_sort_index);

                hv_radian_postive_range = 0;
                hv_radian_negative_range = 0;

                if ((int)(new HTuple((new HTuple(hv_vector_radian_positive.TupleLength())).TupleGreaterEqual(
                    2))) != 0)
                {
                    hv_radian_postive_range = (hv_vector_radian_positive.TupleSelect((new HTuple(hv_vector_radian_positive.TupleLength()
                        )) - 1)) - (hv_vector_radian_positive.TupleSelect(0));
                }
                if ((int)(new HTuple((new HTuple(hv_vector_radian_negative.TupleLength())).TupleGreaterEqual(
                    2))) != 0)
                {
                    hv_radian_negative_range = (hv_vector_radian_negative.TupleSelect((new HTuple(hv_vector_radian_negative.TupleLength()
                        )) - 1)) - (hv_vector_radian_negative.TupleSelect(0));
                }
                hv_radian_range_ = hv_radian_postive_range + hv_radian_negative_range;
                if (hv_radian_range == null)
                    hv_radian_range = new HTuple();
                hv_radian_range[hv_i] = hv_radian_range_;
                if ((int)(new HTuple(hv_radian_range_.TupleEqual(0))) != 0)
                {
                    if (hv_pass_indices == null)
                        hv_pass_indices = new HTuple();
                    hv_pass_indices[hv_i] = 0;
                    continue;
                }
                //(3)
                HOperatorSet.TupleMult(hv_vector_row, hv_vector_row, out hv_vector_row_square);
                HOperatorSet.TupleMult(hv_vector_col, hv_vector_col, out hv_vector_col_square);
                HOperatorSet.TupleSqrt(hv_vector_row_square + hv_vector_col_square, out hv_vector_dist_square);
                HOperatorSet.TupleMean(hv_vector_dist_square, out hv_mean_dist_to_center);
                //(4)
                hv_radian_step = 2.0 / hv_mean_dist_to_center;
                if ((int)((new HTuple((new HTuple(hv_vector_radian_positive.TupleLength()
                    )).TupleGreaterEqual(2))).TupleAnd(new HTuple((new HTuple(hv_vector_radian_negative.TupleLength()
                    )).TupleGreaterEqual(2)))) != 0)
                {
                    hv_radian_all = new HTuple();
                    hv_radian_all = hv_radian_all.TupleConcat(hv_vector_radian_positive);
                    hv_radian_all = hv_radian_all.TupleConcat(hv_vector_radian_negative + ((new HTuple(360)).TupleRad()
                        ));
                }
                else if ((int)(new HTuple((new HTuple(hv_vector_radian_positive.TupleLength()
                    )).TupleGreaterEqual(2))) != 0)
                {
                    hv_radian_all = hv_vector_radian_positive.Clone();
                }
                else if ((int)(new HTuple((new HTuple(hv_vector_radian_negative.TupleLength()
                    )).TupleGreaterEqual(2))) != 0)
                {
                    hv_radian_all = hv_vector_radian_negative.Clone();
                }
                else
                {
                    continue;
                }
                HOperatorSet.TupleGenSequence(hv_radian_all.TupleSelect(0), hv_radian_all.TupleSelect(
                    (new HTuple(hv_radian_all.TupleLength())) - 1), hv_radian_step, out hv_radian_seq);
                HOperatorSet.TupleGenConst((new HTuple(hv_radian_seq.TupleLength())) - 1, 0,
                    out hv_small_part_valid_flag);
                hv_arc_length = hv_mean_dist_to_center * hv_radian_step;
                for (hv_j = 0; (int)hv_j <= (int)((new HTuple(hv_radian_seq.TupleLength())) - 2); hv_j = (int)hv_j + 1)
                {
                    hv_within_angle_range_mask = ((hv_radian_all.TupleLessElem(hv_radian_seq.TupleSelect(
                        hv_j + 1)))).TupleAnd(hv_radian_all.TupleGreaterEqualElem(hv_radian_seq.TupleSelect(
                        hv_j)));
                    HOperatorSet.TupleSum(hv_within_angle_range_mask, out hv_small_part_area);
                    hv_small_part_radial_length_ = (hv_small_part_area + 0.0) / hv_arc_length;
                    if ((int)(new HTuple(hv_small_part_radial_length_.TupleGreater(hv_min_radial_width))) != 0)
                    {
                        if (hv_small_part_valid_flag == null)
                            hv_small_part_valid_flag = new HTuple();
                        hv_small_part_valid_flag[hv_j] = 1;
                    }
                }
                HOperatorSet.TupleInt(hv_min_arc_length / hv_arc_length, out hv_count);
                HOperatorSet.TupleGenConst(hv_count, 1, out hv_continuous_tuple);
                HOperatorSet.TupleFindFirst(hv_small_part_valid_flag, hv_continuous_tuple,
                    out hv_flag);
                if ((int)(new HTuple(hv_flag.TupleNotEqual(-1))) != 0)
                {
                    if (hv_pass_indices == null)
                        hv_pass_indices = new HTuple();
                    hv_pass_indices[hv_i] = 1;
                }
                //stop ()
            }
            ho_region_.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_region_.Dispose();

            throw HDevExpDefaultException;
        }
    }

    private int  Process_(int mode, HObject ho_srcImage_, out HObject glue_region ,out HObject leakage_region, out HObject spot_region,out HObject inside_scar_region, out Result result)
    {
        result = new Result();
        HOperatorSet.SetSystem("temporary_mem_cache", "idle");
        HOperatorSet.GenEmptyRegion(out glue_region);
        HOperatorSet.GenEmptyRegion(out spot_region);
        HOperatorSet.GenEmptyRegion(out leakage_region);
        HOperatorSet.GenEmptyRegion(out inside_scar_region);
        if (!template_ready)
            return -998;
        // Stack for temporary objects 
        HObject[] OTemp = new HObject[20];

        // Local iconic variables 

        HObject ho_srcImage, ho_target_rect;
        HObject ho_srcImage_reduced, ho_overall_dark_region, ho_overall_dark_region_eroded;
        HObject ho_inside_holder_inner_region = null, ho_inside_holder_inner_region_retreated = null;
        HObject ho_inside_holder_outer_region = null, ho_holder_region = null;
        HObject ho_four_rects, ho_glue_region, ho_leakage_region;
        HObject ho_four_rects_ = null, ho_four_rect_holder = null, ho_srcImage_histogram_ = null;
        HObject ho_srcImage_histogram_inverted = null, ho_glue_region_ = null;
        HObject ho_test_leakage_region = null, ho_test_leakage_image = null;
        HObject ho_leakage_region_ = null, ho_holder_image = null, ho_holder_border = null;
        HObject ho_leakage_region_pass = null, ho_upper_border_region;
        HObject ho_lower_border_region, ho_left_border_region, ho_right_border_region;
        HObject ho_all_fringe_region1, ho_all_fringe_region2;
        HObject ho_all_fringe_region, ho_edgeAmp, ho_edgeDir;
        HObject ho_strong_edge_region, ho_edgeDir_reduced, ho_upper_border_image;
        HObject ho_upper_ignore_1, ho_upper_ignore_2, ho_upper_border_region_filled;
        HObject ho_lower_border_image, ho_lower_border_region_filled;
        HObject ho_left_border_image, ho_left_border_region_filled;
        HObject ho_right_border_image, ho_right_border_region_filled;
        HObject ho_fringe_region1, ho_fringe_region2, ho_fringe_region;
        HObject ho_glue_region_connected, ho_ignore_circle, ho_polar_image;
        HObject ho_poar_image_mean, ho_poar_image_mean_0 = new HObject(), ho_spot_region_polar, ho_spot_region;
        HObject ho_yellow_region, ho_red_region, ho_cyan_region;
        HObject ho_ideal_glue_region = null;
        HObject ho_red_region_ = null, ho_yellow_region_ = null, ho_cyan_region_ = null;
        HObject ho_red_glue_region_ = null, ho_yellow_glue_region_ = null;
        HObject ho_cyan_glue_region_ = null;
        HObject ho_test_glue_region = null, ho_srcImage_glue_test = null, ho_srcImage_glue_test_inverted = null;
        //20200306新增檢驗鏡片缺陷
        HObject ho_inside_scar_outer_region = null, ho_inside_scar_inner_region = null, ho_scar_region = null;
        HObject ho_test_scar_region = null, ho_srcImage_scar_test = null, ho_srcImage_scar_test_inverted = null;
        HObject ho_scar_region_ = null, ho_holder_scar_region = null;
        //到此
        // Local control variables 

        HTuple hv_edge_range = null;
        HTuple hv_thresh_offset = null, hv_angle_range;
        HTuple hv_ignore_radius = null, hv_glue_min_area = null;
        HTuple hv_expected_holder_radius1 = null, hv_holder_inner_outer_max_center_offset = null;
        HTuple hv_holder_radius_max_deviate = null;
        HTuple hv_dummy = null, hv_expected_length1 = null, hv_expected_length2 = null;
        HTuple hv_srcWidth = null, hv_srcHeight = null, hv_max_iteration = null;
        HTuple hv_holder_retreat_size = null, hv_numLevels = null;
        HTuple hv_match_row = null, hv_match_col = null, hv_match_angle = null;
        HTuple hv_sample_match_score = null, hv_miss_ncc_score = new HTuple();
        HTuple hv_Rect_MetrologyHandle = null, hv_rectIndex = null;
        HTuple hv_rect_param = null, hv_target_rect_row = null;
        HTuple hv_target_rect_col = null, hv_target_rect_phi = null;
        HTuple hv_target_rect_length1 = null, hv_target_rect_length2 = null;
        HTuple hv_AbsoluteHisto = null, hv_RelativeHisto = null;
        HTuple hv_glue_thresh_all = null, hv_orientation = null;
        HTuple hv_holder_edge_rows1 = null, hv_holder_edge_cols1 = null;
        HTuple hv_holder_edge_rows2 = null, hv_holder_edge_cols2 = null;
        HTuple hv_length_fuzzy_funct = null, hv_intensity_fuzzy_funct = null;
        HTuple hv_i = null, hv_row_offset = new HTuple(), hv_col_offset = new HTuple();
        HTuple hv_MeasureHandle = new HTuple(), hv_RowEdgeFirst = new HTuple();
        HTuple hv_ColumnEdgeFirst = new HTuple(), hv_AmplitudeFirst = new HTuple();
        HTuple hv_RowEdgeSecond = new HTuple(), hv_ColumnEdgeSecond = new HTuple();
        HTuple hv_AmplitudeSecond = new HTuple(), hv_RowEdgeCenter = new HTuple();
        HTuple hv_ColumnEdgeCenter = new HTuple(), hv_FuzzyScore = new HTuple();
        HTuple hv_IntraDistance = new HTuple(), hv_InterDistance = new HTuple();
        //HTuple hv_holder_row1 = null, hv_holder_col1 = null, hv_holder_radius1 = null;
        //HTuple hv_mean_error1 = null, hv_holder_row2 = null, hv_holder_col2 = null;
        //HTuple hv_holder_radius2 = null, hv_mean_error2 = null;
        //20200306新增檢驗鏡片缺陷
        HTuple hv_scar_outer_radius = null, hv_scar_inner_radius = null, hv_scar_thresh_offset = null;
        //到此
        HTuple hv_holder_metro_parameter = null, hv_holder_fail_cond1 = null;
        HTuple hv_holder_fail_cond2 = null, hv_holder_row_offset = new HTuple();
        HTuple hv_holder_col_offset = new HTuple(), hv_holder_center_offset = new HTuple();
        HTuple hv_holderVisible = new HTuple(), hv_holder_MetrologyHandle = new HTuple();
        HTuple hv_holderMetroIndex = new HTuple();//, hv_sample_center_row = new HTuple();
        //HTuple hv_sample_center_col = new HTuple(), hv_sample_radius = new HTuple();
        HTuple hv_grayvalue_threshold = null, hv_probability_threshold = null;
        HTuple hv_leakage_gray_offset = null, hv_target_rect_vector1 = null;
        HTuple hv_target_rect_vector2 = null, hv_four_rect_row1 = null;
        HTuple hv_four_rect_col1 = null, hv_four_rect_row2 = null;
        HTuple hv_four_rect_col2 = null, hv_four_rect_row3 = null;
        HTuple hv_four_rect_col3 = null, hv_four_rect_row4 = null;
        HTuple hv_four_rect_col4 = null, hv_glue_thresh = new HTuple();
        HTuple hv_percent95_grayVal = new HTuple(), hv_j = new HTuple();
        HTuple hv_leakage_min_area = null, hv_leakage_flag = null;
        HTuple hv_leakage_region_count = null, hv_angle_range1 = new HTuple();
        HTuple hv_mean_radial_length = new HTuple(), hv_max_radial_length = new HTuple();
        HTuple hv_radial_width_thresh = new HTuple(), hv_edge_direction_range = null;
        HTuple hv_edge_region_thresh = null, hv_fill_area_thresh = null;
        HTuple hv_slope_area_min_area = null, hv_transMat = null;
        HTuple hv_upper_border_row = null, hv_upper_border_col = null;
        HTuple hv_left_border_row = null, hv_left_border_col = null;
        HTuple hv_right_border_row = null, hv_right_border_col = null;
        HTuple hv_lower_border_row = null, hv_lower_border_col = null;
        HTuple hv_spot_threshold = null, hv_polar_width = null;
        HTuple hv_polar_height = null, hv_red_cyan_radius = null;
        HTuple hv_yellow_red_radius = null;
        HTuple hv_yellow_radius = null;
        HTuple hv_ideal_glue_area = new HTuple();
        HTuple hv_glue_area = null, hv_dumm = null, hv_all_glue_area_ratio = null;
        HTuple hv_yellow_area_ratios = null, hv_cyan_area_ratios = null;
        HTuple hv_red_area_ratios = null, hv_ok = null, hv_red_area = new HTuple();
        HTuple hv_yellow_area = new HTuple(), hv_cyan_area = new HTuple();
        HTuple hv_red_glue_area = new HTuple(), hv_yellow_glue_area = new HTuple();
        HTuple hv_cyan_glue_area = new HTuple(), hv_red_ratio = new HTuple();
        HTuple hv_cyan_ratio = new HTuple(), hv_yellow_ratio = new HTuple();
        HTuple hv_min_arc_length = new HTuple(), hv_leakage_pass_count = new HTuple(), hv_leak_pass_mask = new HTuple();
        HTuple hv_four_area_ratio_ = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_srcImage);
        HOperatorSet.GenEmptyObj(out ho_target_rect);
        HOperatorSet.GenEmptyObj(out ho_srcImage_reduced);
        HOperatorSet.GenEmptyObj(out ho_overall_dark_region);
        HOperatorSet.GenEmptyObj(out ho_overall_dark_region_eroded);
        HOperatorSet.GenEmptyObj(out ho_inside_holder_inner_region);
        HOperatorSet.GenEmptyObj(out ho_inside_holder_inner_region_retreated);
        HOperatorSet.GenEmptyObj(out ho_inside_holder_outer_region);
        HOperatorSet.GenEmptyObj(out ho_holder_region);
        HOperatorSet.GenEmptyObj(out ho_four_rects);
        HOperatorSet.GenEmptyObj(out ho_glue_region);
        HOperatorSet.GenEmptyObj(out ho_leakage_region);
        HOperatorSet.GenEmptyObj(out ho_four_rects_);
        HOperatorSet.GenEmptyObj(out ho_four_rect_holder);
        HOperatorSet.GenEmptyObj(out ho_srcImage_histogram_);
        HOperatorSet.GenEmptyObj(out ho_srcImage_histogram_inverted);
        HOperatorSet.GenEmptyObj(out ho_glue_region_);
        HOperatorSet.GenEmptyObj(out ho_test_leakage_region);
        HOperatorSet.GenEmptyObj(out ho_test_leakage_image);
        HOperatorSet.GenEmptyObj(out ho_leakage_region_);
        HOperatorSet.GenEmptyObj(out ho_holder_image);
        HOperatorSet.GenEmptyObj(out ho_holder_border);
        HOperatorSet.GenEmptyObj(out ho_leakage_region_pass);
        HOperatorSet.GenEmptyObj(out ho_upper_border_region);
        HOperatorSet.GenEmptyObj(out ho_lower_border_region);
        HOperatorSet.GenEmptyObj(out ho_left_border_region);
        HOperatorSet.GenEmptyObj(out ho_right_border_region);
        HOperatorSet.GenEmptyObj(out ho_all_fringe_region1);
        HOperatorSet.GenEmptyObj(out ho_all_fringe_region2);
        HOperatorSet.GenEmptyObj(out ho_all_fringe_region);
        HOperatorSet.GenEmptyObj(out ho_edgeAmp);
        HOperatorSet.GenEmptyObj(out ho_edgeDir);
        HOperatorSet.GenEmptyObj(out ho_strong_edge_region);
        HOperatorSet.GenEmptyObj(out ho_edgeDir_reduced);
        HOperatorSet.GenEmptyObj(out ho_upper_border_image);
        HOperatorSet.GenEmptyObj(out ho_upper_ignore_1);
        HOperatorSet.GenEmptyObj(out ho_upper_ignore_2);
        HOperatorSet.GenEmptyObj(out ho_upper_border_region_filled);
        HOperatorSet.GenEmptyObj(out ho_lower_border_image);
        HOperatorSet.GenEmptyObj(out ho_lower_border_region_filled);
        HOperatorSet.GenEmptyObj(out ho_left_border_image);
        HOperatorSet.GenEmptyObj(out ho_left_border_region_filled);
        HOperatorSet.GenEmptyObj(out ho_right_border_image);
        HOperatorSet.GenEmptyObj(out ho_right_border_region_filled);
        HOperatorSet.GenEmptyObj(out ho_fringe_region1);
        HOperatorSet.GenEmptyObj(out ho_fringe_region2);
        HOperatorSet.GenEmptyObj(out ho_fringe_region);
        HOperatorSet.GenEmptyObj(out ho_glue_region_connected);
        HOperatorSet.GenEmptyObj(out ho_ignore_circle);
        HOperatorSet.GenEmptyObj(out ho_polar_image);
        HOperatorSet.GenEmptyObj(out ho_poar_image_mean);
        HOperatorSet.GenEmptyObj(out ho_spot_region_polar);
        HOperatorSet.GenEmptyObj(out ho_spot_region);
        HOperatorSet.GenEmptyObj(out ho_yellow_region);
        HOperatorSet.GenEmptyObj(out ho_red_region);
        HOperatorSet.GenEmptyObj(out ho_cyan_region);
        HOperatorSet.GenEmptyObj(out ho_ideal_glue_region);
        HOperatorSet.GenEmptyObj(out ho_red_region_);
        HOperatorSet.GenEmptyObj(out ho_yellow_region_);
        HOperatorSet.GenEmptyObj(out ho_cyan_region_);
        HOperatorSet.GenEmptyObj(out ho_red_glue_region_);
        HOperatorSet.GenEmptyObj(out ho_yellow_glue_region_);
        HOperatorSet.GenEmptyObj(out ho_cyan_glue_region_);
        HOperatorSet.GenEmptyObj(out ho_test_glue_region);
        HOperatorSet.GenEmptyObj(out ho_srcImage_glue_test);
        HOperatorSet.GenEmptyObj(out ho_srcImage_glue_test_inverted);
        //20200306新增檢驗鏡片缺陷
        HOperatorSet.GenEmptyObj(out ho_inside_scar_outer_region);
        HOperatorSet.GenEmptyObj(out ho_inside_scar_inner_region);
        HOperatorSet.GenEmptyObj(out ho_scar_region);
        HOperatorSet.GenEmptyObj(out ho_test_scar_region);
        HOperatorSet.GenEmptyObj(out ho_srcImage_scar_test);
        HOperatorSet.GenEmptyObj(out ho_srcImage_scar_test_inverted);
        HOperatorSet.GenEmptyObj(out ho_scar_region_); 
        HOperatorSet.GenEmptyObj(out ho_holder_scar_region);
        //到此

        try
        {
            HOperatorSet.SetSystem("clip_region", "false");
            HOperatorSet.SetSystem("global_mem_cache", "idle");
            //*******////////Create the template of the sample//////////***
            //---Purpose---
            //Use the Correlation model to locate sample position and orientation***

            //---Implementation----

            //---Note---

            //>>>>>>>>>>>>>>>Parameter setting>>>>>>>>>>>>>>>
            //(closed)
            ////param-1//
            hv_edge_range = 25;
            //Name: 边际光晕效应范围
            //Tooltip: 在边界处会有光晕的现象, 因此必须特别处理, 此数值是界定特别处理的范围(以像素为单位)
            //(opened-parameter)
            ////param-1//
            hv_thresh_offset = parameter_set["thresh_offset"];
            //Name: 胶水阀值调整
            //Tooltip: 程式会自动依照照片判定胶水阀值，而此数值则是对程式选取的阀值进行调整，数值越小越容易误判为胶水, 数值越大则越可能漏判为胶水
            //Range: [-10, 10]
            ////param-2//
            hv_angle_range = (new HTuple(parameter_set["angle_range"])).TupleRad();
            //Name: 样品可能角度范围
            //Tooltip: 程式只能接受样品在此角度范围内旋转(已水平为基准)
            //Range: [0, 90]
            ////param-3//
            hv_ignore_radius = parameter_set["ignore_radius"];
            //Name: 忽略圆的半径
            //Tooltip: 对于落在圆半径的黑色区域，程式会忽略
            //Range: [0, infinity]
            ////param-4//
            hv_glue_min_area = parameter_set["glue_min_area"];
            //Name: 独立胶水的最小面积
            //Tooltip: 此数值可以拿来过滤掉一些误判为胶水的小面积部分
            ////param-5//
            hv_expected_holder_radius1 = parameter_set["expected_holder_radius"];
            //Name: 预期固定环半径(以像素为单位)
            //Tooltip:
            ////param-6//
            hv_holder_inner_outer_max_center_offset = 10;
            //Name: 固定环内径和外径的圆心最大偏差值
            //Tooltip: 此数值可以拿来排除一些误判为固定环的可能性
            ////param-7//
            hv_holder_radius_max_deviate = 20;
            //Name: 固定环半径最大可能偏差值
            //Tooltip: 此数值可以拿来排除一些误判为固定环的可能性
            //20200306新增檢驗鏡片缺陷
            ////param-12//
            hv_scar_thresh_offset = parameter_set["scar_thresh_offset"];
            //Name: 
            //Tooltip: 此数值可以拿来排除一些误判为缺陷的可能性
            //<<<<<<<<<<<<<<Parameter setting<<<<<<<<<<<<<<<<
            ho_srcImage.Dispose();
            HOperatorSet.CopyImage(ho_srcImage_, out ho_srcImage);
            HOperatorSet.GetImageSize(ho_srcImage, out hv_srcWidth, out hv_srcHeight);

            //---Purpose---
            //*Locate the rectangle border**

            //---Implementation----
            //1. Use prebuilt NCC model to locate the rough position and orientation of the sample.
            //2. Use the metrology model("MetrologyHandle") to locate the sample rectangle.
            //3. Use my own RANSAC to locate the holder
            //4. If the previous method fails, use the Halcon built-in Metrology Model

            //---Note---
            //>>>>>>>>>>>>>>>Parameter setting>>>>>>>>>>>>>>>
            //(closed)
            ////param-1//
            hv_max_iteration = 100;
            //Name: RANSAC的最大iteration数
            //Tooltip: 数字越大越慢, 但数字太小可能会停留在错误的结果
            ////param-2//
            hv_holder_retreat_size = 10;
            //Name: RANSAC的最大iteration数
            //Tooltip: 数字越大越慢, 但数字太小可能会停留在错误的结果
            //<<<<<<<<<<<<<<Parameter setting<<<<<<<<<<<<<<<<<
            //(1)
            hv_numLevels = 5;
            HOperatorSet.FindNccModel(ho_srcImage, hv_sample_NCC_ModelID, -hv_angle_range
            , 2 * hv_angle_range, 0.3, 1, 0, "true", hv_numLevels, out hv_match_row, out hv_match_col,
                out hv_match_angle, out hv_sample_match_score);
            if ((int)(new HTuple((new HTuple(hv_sample_match_score.TupleLength())).TupleEqual(
                0))) != 0)
            {
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispObj(ho_srcImage, HDevWindowStack.GetActive());
                }
                HOperatorSet.FindNccModel(ho_srcImage, hv_empty_NCC_ModelID, -0.1, 0.1, 0.5,
                    1, 0, "false", 5, out hv_dummy, out hv_dummy, out hv_dummy, out hv_miss_ncc_score);
                if ((int)(new HTuple((new HTuple(hv_miss_ncc_score.TupleLength())).TupleEqual(
                    1))) != 0)
                {
                    ho_srcImage.Dispose();
                    ho_target_rect.Dispose();
                    ho_srcImage_reduced.Dispose();
                    ho_overall_dark_region.Dispose();
                    ho_overall_dark_region_eroded.Dispose();
                    ho_inside_holder_inner_region.Dispose();
                    ho_inside_holder_inner_region_retreated.Dispose();
                    ho_inside_holder_outer_region.Dispose();
                    ho_holder_region.Dispose();
                    ho_four_rects.Dispose();
                    ho_glue_region.Dispose();
                    ho_leakage_region.Dispose();
                    ho_four_rects_.Dispose();
                    ho_four_rect_holder.Dispose();
                    ho_srcImage_histogram_.Dispose();
                    ho_srcImage_histogram_inverted.Dispose();
                    ho_glue_region_.Dispose();
                    ho_test_leakage_region.Dispose();
                    ho_test_leakage_image.Dispose();
                    ho_leakage_region_.Dispose();
                    ho_holder_image.Dispose();
                    ho_holder_border.Dispose();
                    ho_leakage_region_pass.Dispose();
                    ho_upper_border_region.Dispose();
                    ho_lower_border_region.Dispose();
                    ho_left_border_region.Dispose();
                    ho_right_border_region.Dispose();
                    ho_all_fringe_region1.Dispose();
                    ho_all_fringe_region2.Dispose();
                    ho_all_fringe_region.Dispose();
                    ho_edgeAmp.Dispose();
                    ho_edgeDir.Dispose();
                    ho_strong_edge_region.Dispose();
                    ho_edgeDir_reduced.Dispose();
                    ho_upper_border_image.Dispose();
                    ho_upper_ignore_1.Dispose();
                    ho_upper_ignore_2.Dispose();
                    ho_upper_border_region_filled.Dispose();
                    ho_lower_border_image.Dispose();
                    ho_lower_border_region_filled.Dispose();
                    ho_left_border_image.Dispose();
                    ho_left_border_region_filled.Dispose();
                    ho_right_border_image.Dispose();
                    ho_right_border_region_filled.Dispose();
                    ho_fringe_region1.Dispose();
                    ho_fringe_region2.Dispose();
                    ho_fringe_region.Dispose();
                    ho_glue_region_connected.Dispose();
                    ho_ignore_circle.Dispose();
                    ho_polar_image.Dispose();
                    ho_poar_image_mean.Dispose();
                    ho_spot_region_polar.Dispose();
                    ho_spot_region.Dispose();
                    ho_yellow_region.Dispose();
                    ho_red_region.Dispose();
                    ho_cyan_region.Dispose();
                    ho_ideal_glue_region.Dispose();
                    ho_red_region_.Dispose();
                    ho_yellow_region_.Dispose();
                    ho_cyan_region_.Dispose();
                    ho_red_glue_region_.Dispose();
                    ho_yellow_glue_region_.Dispose();
                    ho_cyan_glue_region_.Dispose();
                    ho_test_glue_region.Dispose();
                    ho_srcImage_glue_test.Dispose();
                    ho_srcImage_glue_test_inverted.Dispose();
                    return -1;
                }
                else
                {
                    ho_srcImage.Dispose();
                    ho_target_rect.Dispose();
                    ho_srcImage_reduced.Dispose();
                    ho_overall_dark_region.Dispose();
                    ho_overall_dark_region_eroded.Dispose();
                    ho_inside_holder_inner_region.Dispose();
                    ho_inside_holder_inner_region_retreated.Dispose();
                    ho_inside_holder_outer_region.Dispose();
                    ho_holder_region.Dispose();
                    ho_four_rects.Dispose();
                    ho_glue_region.Dispose();
                    ho_leakage_region.Dispose();
                    ho_four_rects_.Dispose();
                    ho_four_rect_holder.Dispose();
                    ho_srcImage_histogram_.Dispose();
                    ho_srcImage_histogram_inverted.Dispose();
                    ho_glue_region_.Dispose();
                    ho_test_leakage_region.Dispose();
                    ho_test_leakage_image.Dispose();
                    ho_leakage_region_.Dispose();
                    ho_holder_image.Dispose();
                    ho_holder_border.Dispose();
                    ho_leakage_region_pass.Dispose();
                    ho_upper_border_region.Dispose();
                    ho_lower_border_region.Dispose();
                    ho_left_border_region.Dispose();
                    ho_right_border_region.Dispose();
                    ho_all_fringe_region1.Dispose();
                    ho_all_fringe_region2.Dispose();
                    ho_all_fringe_region.Dispose();
                    ho_edgeAmp.Dispose();
                    ho_edgeDir.Dispose();
                    ho_strong_edge_region.Dispose();
                    ho_edgeDir_reduced.Dispose();
                    ho_upper_border_image.Dispose();
                    ho_upper_ignore_1.Dispose();
                    ho_upper_ignore_2.Dispose();
                    ho_upper_border_region_filled.Dispose();
                    ho_lower_border_image.Dispose();
                    ho_lower_border_region_filled.Dispose();
                    ho_left_border_image.Dispose();
                    ho_left_border_region_filled.Dispose();
                    ho_right_border_image.Dispose();
                    ho_right_border_region_filled.Dispose();
                    ho_fringe_region1.Dispose();
                    ho_fringe_region2.Dispose();
                    ho_fringe_region.Dispose();
                    ho_glue_region_connected.Dispose();
                    ho_ignore_circle.Dispose();
                    ho_polar_image.Dispose();
                    ho_poar_image_mean.Dispose();
                    ho_spot_region_polar.Dispose();
                    ho_spot_region.Dispose();
                    ho_yellow_region.Dispose();
                    ho_red_region.Dispose();
                    ho_cyan_region.Dispose();
                    ho_ideal_glue_region.Dispose();
                    ho_red_region_.Dispose();
                    ho_yellow_region_.Dispose();
                    ho_cyan_region_.Dispose();
                    ho_red_glue_region_.Dispose();
                    ho_yellow_glue_region_.Dispose();
                    ho_cyan_glue_region_.Dispose();
                    ho_test_glue_region.Dispose();
                    ho_srcImage_glue_test.Dispose();
                    ho_srcImage_glue_test_inverted.Dispose();
                    return -4;
                }
            }
            //20200306新增檢驗鏡片缺陷
            //>>>>>>>>>>>>>>>Parameter setting>>>>>>>>>>>>>>>
            //(opened-parameter)
            ////param-11//
            hv_scar_outer_radius = parameter_set["scar_outer_radius"];
            //Name: 鏡片缺陷外直徑
            //Tooltip:
            ////param-12//
            hv_scar_inner_radius = parameter_set["scar_inner_radius"];
            //Name: 鏡片缺陷內直徑
            //Tooltip:
            //<<<<<<<<<<<<<<Parameter setting<<<<<<<<<<<<<<<<<
            //(2)
            hv_expected_length1 = parameter_set["expected_length1"];
            hv_expected_length2 = parameter_set["expected_length2"];


            HObject ho_Contour = new HObject(), ho_ResultContours = new HObject(), ho_UsedEdges = new HObject();
            HTuple hv_CenterRow = new HTuple(), hv_CenterColumn = new HTuple(), hv_CenterPhi = new HTuple(), hv_CenterLength1 = new HTuple(), hv_CenterLength2 = new HTuple();
            int iResult = 0;
            HTuple hv_Length1 = My.NIR.Length1_RectangleCenter;
            HTuple hv_Length2 = My.NIR.Length2_RectangleCenter;
            HTuple hv_Length = My.NIR.Length_RectangleCenter;
            HTuple hv_Phi = My.NIR.Phi_RectangleCenter;
            HTuple hv_MeasureThreshold = My.NIR.MeasureThreshold_RectangleCenter;
            HTuple hv_MeasureTransition = My.NIR.MeasureTransition_RectangleCenter;
            HTuple hv_MeasureSelect = My.NIR.MeasureSelect_RectangleCenter.D == 0 ? "first" : "last";

            try
            {
                //第一次先找圓心
                ho_UsedEdges.Dispose(); ho_Contour.Dispose(); ho_ResultContours.Dispose();
                gen_rectangle2_center(ho_srcImage, out ho_Contour, out ho_UsedEdges,
                   out ho_ResultContours, hv_match_row, hv_match_col, hv_Phi, hv_Length1, hv_Length2,
                   hv_Length, hv_MeasureThreshold, hv_MeasureTransition, hv_MeasureSelect, out hv_CenterRow, out hv_CenterColumn, out hv_CenterPhi,
                   out hv_CenterLength1, out hv_CenterLength2);
                if (hv_CenterRow != null)
                {
                    hv_target_rect_row = hv_CenterRow;
                    hv_target_rect_col = hv_CenterColumn;
                    hv_target_rect_phi = hv_CenterPhi;
                    hv_target_rect_length1 = hv_CenterLength1;
                    hv_target_rect_length2 = hv_CenterLength2;
                    iResult = 1;
                }
            }
            catch
            {
                iResult = 0;
            }


            //HOperatorSet.CreateMetrologyModel(out hv_Rect_MetrologyHandle);
            //HOperatorSet.SetMetrologyModelImageSize(hv_Rect_MetrologyHandle, hv_srcWidth,
            //    hv_srcHeight);
            //HOperatorSet.AddMetrologyObjectRectangle2Measure(hv_Rect_MetrologyHandle, hv_match_row,
            //    hv_match_col, hv_match_angle, hv_expected_length1, hv_expected_length2,
            //    30, 5, 1, 10, "measure_transition", "positive", out hv_rectIndex);
            //HOperatorSet.SetMetrologyObjectParam(hv_Rect_MetrologyHandle, "all", ((new HTuple("max_num_iterations")).TupleConcat(
            //    "num_instances")).TupleConcat("measure_transition"), hv_max_iteration.TupleConcat(
            //    (new HTuple(1)).TupleConcat("positive")));
            //HOperatorSet.ApplyMetrologyModel(ho_srcImage, hv_Rect_MetrologyHandle);
            //HOperatorSet.GetMetrologyObjectResult(hv_Rect_MetrologyHandle, hv_rectIndex,
            //    "all", "result_type", "all_param", out hv_rect_param);
            //HOperatorSet.ClearMetrologyModel(hv_Rect_MetrologyHandle);
            if (iResult != 1)
            {
                ho_srcImage.Dispose();
                ho_target_rect.Dispose();
                ho_srcImage_reduced.Dispose();
                ho_overall_dark_region.Dispose();
                ho_overall_dark_region_eroded.Dispose();
                ho_inside_holder_inner_region.Dispose();
                ho_inside_holder_inner_region_retreated.Dispose();
                ho_inside_holder_outer_region.Dispose();
                ho_holder_region.Dispose();
                ho_four_rects.Dispose();
                ho_glue_region.Dispose();
                ho_leakage_region.Dispose();
                ho_four_rects_.Dispose();
                ho_four_rect_holder.Dispose();
                ho_srcImage_histogram_.Dispose();
                ho_srcImage_histogram_inverted.Dispose();
                ho_glue_region_.Dispose();
                ho_test_leakage_region.Dispose();
                ho_test_leakage_image.Dispose();
                ho_leakage_region_.Dispose();
                ho_holder_image.Dispose();
                ho_holder_border.Dispose();
                ho_leakage_region_pass.Dispose();
                ho_upper_border_region.Dispose();
                ho_lower_border_region.Dispose();
                ho_left_border_region.Dispose();
                ho_right_border_region.Dispose();
                ho_all_fringe_region1.Dispose();
                ho_all_fringe_region2.Dispose();
                ho_all_fringe_region.Dispose();
                ho_edgeAmp.Dispose();
                ho_edgeDir.Dispose();
                ho_strong_edge_region.Dispose();
                ho_edgeDir_reduced.Dispose();
                ho_upper_border_image.Dispose();
                ho_upper_ignore_1.Dispose();
                ho_upper_ignore_2.Dispose();
                ho_upper_border_region_filled.Dispose();
                ho_lower_border_image.Dispose();
                ho_lower_border_region_filled.Dispose();
                ho_left_border_image.Dispose();
                ho_left_border_region_filled.Dispose();
                ho_right_border_image.Dispose();
                ho_right_border_region_filled.Dispose();
                ho_fringe_region1.Dispose();
                ho_fringe_region2.Dispose();
                ho_fringe_region.Dispose();
                ho_glue_region_connected.Dispose();
                ho_ignore_circle.Dispose();
                ho_polar_image.Dispose();
                ho_poar_image_mean.Dispose();
                ho_spot_region_polar.Dispose();
                ho_spot_region.Dispose();
                ho_yellow_region.Dispose();
                ho_red_region.Dispose();
                ho_cyan_region.Dispose();
                ho_ideal_glue_region.Dispose();
                ho_red_region_.Dispose();
                ho_yellow_region_.Dispose();
                ho_cyan_region_.Dispose();
                ho_red_glue_region_.Dispose();
                ho_yellow_glue_region_.Dispose();
                ho_cyan_glue_region_.Dispose();
                ho_test_glue_region.Dispose();
                ho_srcImage_glue_test.Dispose();
                ho_srcImage_glue_test_inverted.Dispose();
                return -2;
            }
            
            ho_target_rect.Dispose();
            HOperatorSet.GenRectangle2(out ho_target_rect, hv_target_rect_row,
                hv_target_rect_col, hv_target_rect_phi, hv_target_rect_length1, hv_target_rect_length2);
            ho_srcImage_reduced.Dispose();
            HOperatorSet.ReduceDomain(ho_srcImage, ho_target_rect, out ho_srcImage_reduced
                );
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.BilateralFilter(ho_srcImage_reduced, ho_srcImage_reduced, out ExpTmpOutVar_0,
                    3, 20, new HTuple(), new HTuple());
                ho_srcImage_reduced.Dispose();
                ho_srcImage_reduced = ExpTmpOutVar_0;
            }

            HOperatorSet.GrayHisto(ho_target_rect, ho_srcImage_reduced, out hv_AbsoluteHisto,
                out hv_RelativeHisto);
            Ostu_Threshold(hv_AbsoluteHisto, 0.01, 200, out hv_glue_thresh_all);
            ho_overall_dark_region.Dispose();
            HOperatorSet.Threshold(ho_srcImage_reduced, out ho_overall_dark_region, 0,
                hv_glue_thresh_all);
            ho_overall_dark_region_eroded.Dispose();
            HOperatorSet.ErosionCircle(ho_overall_dark_region, out ho_overall_dark_region_eroded,
                5.5);

            //(3)
            HOperatorSet.TupleGenSequence((new HTuple(0)).TupleRad(), (new HTuple(360)).TupleRad()
                , (new HTuple(2.5)).TupleRad(), out hv_orientation);
            hv_holder_edge_rows1 = new HTuple();
            hv_holder_edge_cols1 = new HTuple();
            hv_holder_edge_rows2 = new HTuple();
            hv_holder_edge_cols2 = new HTuple();

            HOperatorSet.CreateFunct1dPairs((((((new HTuple(0)).TupleConcat(5)).TupleConcat(
                7)).TupleConcat(9)).TupleConcat(11)).TupleConcat(13), (((((new HTuple(0)).TupleConcat(
                0.5)).TupleConcat(1)).TupleConcat(1)).TupleConcat(0.5)).TupleConcat(0),
                out hv_length_fuzzy_funct);
            HOperatorSet.CreateFunct1dPairs((((new HTuple(0)).TupleConcat(hv_glue_thresh_all))).TupleConcat(
                hv_glue_thresh_all + 5), ((new HTuple(1)).TupleConcat(1)).TupleConcat(0),
                out hv_intensity_fuzzy_funct);

            for (hv_i = 0; (int)hv_i <= (int)((new HTuple(hv_orientation.TupleLength())) - 1); hv_i = (int)hv_i + 1)
            {
                hv_row_offset = (-hv_expected_holder_radius1) * (((hv_orientation.TupleSelect(
                    hv_i))).TupleSin());
                hv_col_offset = hv_expected_holder_radius1 * (((hv_orientation.TupleSelect(
                    hv_i))).TupleCos());
                HOperatorSet.GenMeasureRectangle2((hv_target_rect_row) + hv_row_offset,
                    (hv_target_rect_col) + hv_col_offset, hv_orientation.TupleSelect(
                    hv_i), 40, 3, hv_srcWidth, hv_srcHeight, "nearest_neighbor", out hv_MeasureHandle);
                //set_fuzzy_measure (MeasureHandle, 'size', length_fuzzy_funct)
                HOperatorSet.SetFuzzyMeasure(hv_MeasureHandle, "gray", hv_intensity_fuzzy_funct);
                HOperatorSet.FuzzyMeasurePairs(ho_srcImage_reduced, hv_MeasureHandle, 1.7,
                    1, 0.3, "negative", out hv_RowEdgeFirst, out hv_ColumnEdgeFirst, out hv_AmplitudeFirst,
                    out hv_RowEdgeSecond, out hv_ColumnEdgeSecond, out hv_AmplitudeSecond,
                    out hv_RowEdgeCenter, out hv_ColumnEdgeCenter, out hv_FuzzyScore, out hv_IntraDistance,
                    out hv_InterDistance);
                if ((int)(new HTuple((new HTuple(hv_RowEdgeFirst.TupleLength())).TupleNotEqual(
                    0))) != 0)
                {
                    hv_holder_edge_rows1 = hv_holder_edge_rows1.TupleConcat(hv_RowEdgeFirst);
                    hv_holder_edge_cols1 = hv_holder_edge_cols1.TupleConcat(hv_ColumnEdgeFirst);
                    hv_holder_edge_rows2 = hv_holder_edge_rows2.TupleConcat(hv_RowEdgeSecond);
                    hv_holder_edge_cols2 = hv_holder_edge_cols2.TupleConcat(hv_ColumnEdgeSecond);
                }
                HOperatorSet.CloseMeasure(hv_MeasureHandle);
            }
            hv_holderVisible = 0;
            //2020/12/3找圓開放設置
            HObject ho_UsedEdges_Center = new HObject(), ho_Contour_Center = new HObject(), ho_ResultContours_Center = new HObject(), ho_CrossCenter_Center = new HObject();
            
            hv_CenterRow = new HTuple();
            hv_CenterColumn = new HTuple();
            HTuple hv_CenterRadius = new HTuple();
            HTuple hv_Radius_Center = My.NIR.Radius_Center;
            HTuple hv_Length_Center = My.NIR.Length_Center;
            HTuple MeasureSelect_Center = My.NIR.MeasureSelect_Center.D == 0 ? "first" : "last";
            HTuple MeasureThreshold_Center = My.NIR.MeasureThreshold_Center;
            HTuple MeasureTransition_Center = My.NIR.MeasureTransition_Center;

            gen_circle_center(ho_srcImage, out ho_UsedEdges_Center, out ho_Contour_Center, out ho_ResultContours_Center, out ho_CrossCenter_Center,
                hv_match_row, hv_match_col, hv_Radius_Center, hv_Length_Center, MeasureThreshold_Center, MeasureTransition_Center, MeasureSelect_Center
                , out hv_CenterRow, out hv_CenterColumn, out hv_CenterRadius);
            //傳出圓心,為了給手動設定使用
            if (hv_CenterRow != null)
            {
                My.NIR.hv_CenterRow = hv_CenterRow;
                My.NIR.hv_CenterColumn = hv_CenterColumn;
            }
            //20200306新增檢驗鏡片缺陷
            ho_inside_scar_outer_region.Dispose();
            HOperatorSet.GenCircle(out ho_inside_scar_outer_region, hv_CenterRow, hv_CenterColumn, hv_scar_outer_radius);
            ho_inside_scar_inner_region.Dispose();
            HOperatorSet.GenCircle(out ho_inside_scar_inner_region, hv_CenterRow, hv_CenterColumn, hv_scar_inner_radius);
            ho_holder_scar_region.Dispose();
            HOperatorSet.Difference(ho_inside_scar_outer_region, ho_inside_scar_inner_region,out ho_holder_scar_region);
            //20201203新增檢測去掉檢測區域

            HOperatorSet.GenCircle(out ho_inside_holder_inner_region, hv_CenterRow, hv_CenterColumn, hv_expected_holder_radius1);

            ////抓8958固定環(舊的)202012/3更改
            //RANSAC_FIT_CIRCLE(ho_srcImage, hv_holder_edge_rows1, hv_holder_edge_cols1,
            //    200, 5, out hv_holder_row1, out hv_holder_col1, out hv_holder_radius1,
            //    out hv_mean_error1);
            //RANSAC_FIT_CIRCLE(ho_srcImage, hv_holder_edge_rows2, hv_holder_edge_cols2,
            //    200, 5, out hv_holder_row2, out hv_holder_col2, out hv_holder_radius2,
            //    out hv_mean_error2);

            //hv_holder_metro_parameter = new HTuple();
            ////(4)
            ////My own method fails to locate the ring.
            ////If the center of the inner circle and outer circle of the holder are displaced too much, it is wrong.
            //hv_holder_fail_cond1 = (new HTuple(hv_holder_radius1.TupleEqual(-1))).TupleOr(
            //    new HTuple(hv_holder_radius2.TupleEqual(-1)));
            //hv_holder_fail_cond2 = 0;
            //if ((int)(hv_holder_fail_cond1.TupleNot()) != 0)
            //{
            //    hv_holder_row_offset = hv_holder_row1 - hv_holder_row2;
            //    hv_holder_col_offset = hv_holder_col1 - hv_holder_col2;
            //    HOperatorSet.TupleSqrt((hv_holder_row_offset * hv_holder_row_offset) + (hv_holder_col_offset * hv_holder_col_offset),
            //        out hv_holder_center_offset);
            //    if ((int)((new HTuple(hv_holder_center_offset.TupleGreater(hv_holder_inner_outer_max_center_offset))).TupleOr(
            //        new HTuple(((((hv_holder_radius1 - hv_expected_holder_radius1)).TupleAbs()
            //        )).TupleGreater(20)))) != 0)
            //    {
            //        hv_holder_fail_cond2 = 1;
            //    }
            //}
            //if ((int)(hv_holder_fail_cond1.TupleOr(hv_holder_fail_cond2)) != 0)
            //{
            //    hv_holderVisible = 0;
            //    HOperatorSet.CreateMetrologyModel(out hv_holder_MetrologyHandle);
            //    HOperatorSet.SetMetrologyModelImageSize(hv_holder_MetrologyHandle, hv_srcWidth,
            //        hv_srcHeight);
            //    HOperatorSet.AddMetrologyObjectCircleMeasure(hv_holder_MetrologyHandle, hv_rect_param.TupleSelect(
            //        0), hv_rect_param.TupleSelect(1), hv_expected_holder_radius1, 30, 5,
            //        1.7, 1, "measure_transition", "negative", out hv_holderMetroIndex);
            //    HOperatorSet.SetMetrologyObjectParam(hv_holder_MetrologyHandle, "all", ((new HTuple("max_num_iterations")).TupleConcat(
            //        "num_instances")).TupleConcat("measure_transition"), ((new HTuple(200)).TupleConcat(
            //        1)).TupleConcat("negative"));
            //    HOperatorSet.ApplyMetrologyModel(ho_srcImage, hv_holder_MetrologyHandle);
            //    HOperatorSet.GetMetrologyObjectResult(hv_holder_MetrologyHandle, hv_holderMetroIndex,
            //        "all", "result_type", "all_param", out hv_holder_metro_parameter);
            //    HOperatorSet.ClearMetrologyModel(hv_holder_MetrologyHandle);

            //    if ((int)(new HTuple((new HTuple(hv_holder_metro_parameter.TupleLength())).TupleNotEqual(
            //        0))) != 0)
            //    {
            //        ho_inside_holder_inner_region.Dispose();
            //        HOperatorSet.GenCircle(out ho_inside_holder_inner_region, hv_holder_metro_parameter.TupleSelect(
            //            0), hv_holder_metro_parameter.TupleSelect(1), hv_holder_metro_parameter.TupleSelect(
            //            2));
            //        ho_inside_holder_inner_region_retreated.Dispose();
            //        HOperatorSet.GenCircle(out ho_inside_holder_inner_region_retreated, hv_holder_metro_parameter.TupleSelect(
            //            0), hv_holder_metro_parameter.TupleSelect(1), (hv_holder_metro_parameter.TupleSelect(
            //            2)) - hv_holder_retreat_size);
            //        //20200306新增檢驗鏡片缺陷
            //        ho_inside_scar_outer_region.Dispose();
            //        HOperatorSet.GenCircle(out ho_inside_scar_outer_region, hv_holder_metro_parameter.TupleSelect(
            //            0), hv_holder_metro_parameter.TupleSelect(1), hv_scar_outer_radius);
            //        ho_inside_scar_inner_region.Dispose();
            //        HOperatorSet.GenCircle(out ho_inside_scar_inner_region, hv_holder_metro_parameter.TupleSelect(
            //            0), hv_holder_metro_parameter.TupleSelect(1), hv_scar_inner_radius);
            //        ho_holder_scar_region.Dispose();
            //        HOperatorSet.Difference(ho_inside_scar_outer_region, ho_inside_scar_inner_region,
            //            out ho_holder_scar_region);
            //        //到此
            //        hv_sample_center_row = hv_holder_metro_parameter.TupleSelect(0);
            //        hv_sample_center_col = hv_holder_metro_parameter.TupleSelect(1);
            //        hv_sample_radius = hv_holder_metro_parameter.TupleSelect(2);
            //    }
            //    else
            //    {
            //        //Even the backup method using Halcon's built-in MetrologyModel does not work out.
            //        ho_srcImage.Dispose();
            //        ho_target_rect.Dispose();
            //        ho_srcImage_reduced.Dispose();
            //        ho_overall_dark_region.Dispose();
            //        ho_overall_dark_region_eroded.Dispose();
            //        ho_inside_holder_inner_region.Dispose();
            //        ho_inside_holder_inner_region_retreated.Dispose();
            //        ho_inside_holder_outer_region.Dispose();
            //        ho_holder_region.Dispose();
            //        ho_four_rects.Dispose();
            //        ho_glue_region.Dispose();
            //        ho_leakage_region.Dispose();
            //        ho_four_rects_.Dispose();
            //        ho_four_rect_holder.Dispose();
            //        ho_srcImage_histogram_.Dispose();
            //        ho_srcImage_histogram_inverted.Dispose();
            //        ho_glue_region_.Dispose();
            //        ho_test_leakage_region.Dispose();
            //        ho_test_leakage_image.Dispose();
            //        ho_leakage_region_.Dispose();
            //        ho_holder_image.Dispose();
            //        ho_holder_border.Dispose();
            //        ho_leakage_region_pass.Dispose();
            //        ho_upper_border_region.Dispose();
            //        ho_lower_border_region.Dispose();
            //        ho_left_border_region.Dispose();
            //        ho_right_border_region.Dispose();
            //        ho_all_fringe_region1.Dispose();
            //        ho_all_fringe_region2.Dispose();
            //        ho_all_fringe_region.Dispose();
            //        ho_edgeAmp.Dispose();
            //        ho_edgeDir.Dispose();
            //        ho_strong_edge_region.Dispose();
            //        ho_edgeDir_reduced.Dispose();
            //        ho_upper_border_image.Dispose();
            //        ho_upper_ignore_1.Dispose();
            //        ho_upper_ignore_2.Dispose();
            //        ho_upper_border_region_filled.Dispose();
            //        ho_lower_border_image.Dispose();
            //        ho_lower_border_region_filled.Dispose();
            //        ho_left_border_image.Dispose();
            //        ho_left_border_region_filled.Dispose();
            //        ho_right_border_image.Dispose();
            //        ho_right_border_region_filled.Dispose();
            //        ho_fringe_region1.Dispose();
            //        ho_fringe_region2.Dispose();
            //        ho_fringe_region.Dispose();
            //        ho_glue_region_connected.Dispose();
            //        ho_ignore_circle.Dispose();
            //        ho_polar_image.Dispose();
            //        ho_poar_image_mean.Dispose();
            //        ho_spot_region_polar.Dispose();
            //        ho_spot_region.Dispose();
            //        ho_yellow_region.Dispose();
            //        ho_red_region.Dispose();
            //        ho_cyan_region.Dispose();
            //        ho_ideal_glue_region.Dispose();
            //        ho_red_region_.Dispose();
            //        ho_yellow_region_.Dispose();
            //        ho_cyan_region_.Dispose();
            //        ho_red_glue_region_.Dispose();
            //        ho_yellow_glue_region_.Dispose();
            //        ho_cyan_glue_region_.Dispose();
            //        ho_test_glue_region.Dispose();
            //        ho_srcImage_glue_test.Dispose();
            //        ho_srcImage_glue_test_inverted.Dispose();
            //        return -3;
            //    }
            //}
            //else
            //{
            //    My own method successfully locates the ring.
            //    hv_holderVisible = 1;
            //    ho_inside_holder_inner_region.Dispose();
            //    HOperatorSet.GenCircle(out ho_inside_holder_inner_region, hv_holder_row1,
            //        hv_holder_col1, hv_holder_radius1);
            //    ho_inside_holder_outer_region.Dispose();
            //    HOperatorSet.GenCircle(out ho_inside_holder_outer_region, hv_holder_row2,
            //        hv_holder_col2, hv_holder_radius2);
            //    ho_inside_holder_inner_region_retreated.Dispose();
            //    HOperatorSet.GenCircle(out ho_inside_holder_inner_region_retreated, hv_holder_row2,
            //        hv_holder_col2, hv_holder_radius2 - hv_holder_retreat_size);
            //    ho_holder_region.Dispose();
            //    HOperatorSet.Difference(ho_inside_holder_outer_region, ho_inside_holder_inner_region,
            //        out ho_holder_region);
            //    20200306新增檢驗鏡片缺陷
            //    ho_inside_scar_outer_region.Dispose();
            //    HOperatorSet.GenCircle(out ho_inside_scar_outer_region, hv_holder_row2, hv_holder_col2, hv_scar_outer_radius);
            //    ho_inside_scar_inner_region.Dispose();
            //    HOperatorSet.GenCircle(out ho_inside_scar_inner_region, hv_holder_row1, hv_holder_col1, hv_scar_inner_radius);
            //    ho_holder_scar_region.Dispose();
            //    HOperatorSet.Difference(ho_inside_scar_outer_region, ho_inside_scar_inner_region,
            //        out ho_holder_scar_region);
            //    到此
            //    hv_sample_center_row = (hv_holder_row1 + hv_holder_row2) / 2;
            //    hv_sample_center_col = (hv_holder_col1 + hv_holder_col2) / 2;
            //    hv_sample_radius = hv_holder_radius1.Clone();
            //}

            //---Purpose---
            //*Locate the region of glue and the suspective bright region that may be glue leakage**

            //---Implementation----
            //1. Divide the sample rectangle into four small rectangle of equal size to avoid the intensity difference in these four rectanglar regions.
            //2. Use simple Ostu's method to decide the threshold
            //3. Case1: Holder is successfully located
            //               The sample has an intrinsic dark holder, which will be faslely classified as glue so special care should be taken.
            //   Case2: Holder is failed to be found
            //               The steps in case 1 are ignored.
            //4. Use simple method based on histogram to locate the bright region inside or near the holder.

            //>>>>>>>>>>>>>>>Parameter setting>>>>>>>>>>>>>>>
            //(closed)
            ////param-1//
            hv_grayvalue_threshold = 100;
            //Name: 灰阶忽略阈值
            //Tooltip: histogram当中灰阶高于此数值的都会被忽略不计, 也就是归零
            ////param-2//
            hv_probability_threshold = 0.01;
            //Name: 机率忽略阈值
            //Tooltip: histogram当中机率低于此数值的都会被忽略不计, 也就是归零
            ////param-3//
            hv_leakage_gray_offset = parameter_set["leakage_gray_offset"];
            //Name:
            //Tooltip:
            //(opened-parameter)
            //<<<<<<<<<<<<<<Parameter setting<<<<<<<<<<<<<<<<<
            //(1)
            hv_target_rect_vector1 = new HTuple();
            hv_target_rect_vector1 = hv_target_rect_vector1.TupleConcat((-hv_target_rect_length1) * (hv_target_rect_phi.TupleSin()
                ));
            hv_target_rect_vector1 = hv_target_rect_vector1.TupleConcat(hv_target_rect_length1 * (hv_target_rect_phi.TupleCos()
                ));
            hv_target_rect_vector2 = new HTuple();
            hv_target_rect_vector2 = hv_target_rect_vector2.TupleConcat((-hv_target_rect_length2) * (hv_target_rect_phi.TupleCos()
                ));
            hv_target_rect_vector2 = hv_target_rect_vector2.TupleConcat((-hv_target_rect_length2) * (hv_target_rect_phi.TupleSin()
                ));
            hv_four_rect_row1 = (((hv_target_rect_vector1.TupleSelect(0)) * (((new HTuple(-1)).TupleConcat(
                0)).TupleConcat(0)).TupleConcat(-1)) + ((hv_target_rect_vector2.TupleSelect(
                0)) * (((new HTuple(1)).TupleConcat(1)).TupleConcat(0)).TupleConcat(0))) + hv_target_rect_row;
            hv_four_rect_col1 = (((hv_target_rect_vector1.TupleSelect(1)) * (((new HTuple(-1)).TupleConcat(
                0)).TupleConcat(0)).TupleConcat(-1)) + ((hv_target_rect_vector2.TupleSelect(
                1)) * (((new HTuple(1)).TupleConcat(1)).TupleConcat(0)).TupleConcat(0))) + hv_target_rect_col;
            hv_four_rect_row2 = hv_four_rect_row1 + (hv_target_rect_vector1.TupleSelect(0));
            hv_four_rect_col2 = hv_four_rect_col1 + (hv_target_rect_vector1.TupleSelect(1));
            hv_four_rect_row3 = hv_four_rect_row2 - (hv_target_rect_vector2.TupleSelect(0));
            hv_four_rect_col3 = hv_four_rect_col2 - (hv_target_rect_vector2.TupleSelect(1));
            hv_four_rect_row4 = hv_four_rect_row1 - (hv_target_rect_vector2.TupleSelect(0));
            hv_four_rect_col4 = hv_four_rect_col1 - (hv_target_rect_vector2.TupleSelect(1));

            ho_four_rects.Dispose();
            HOperatorSet.GenEmptyObj(out ho_four_rects);
            ho_glue_region.Dispose();
            HOperatorSet.GenEmptyRegion(out ho_glue_region);
            ho_leakage_region.Dispose();
            HOperatorSet.GenEmptyRegion(out ho_leakage_region);

            for (hv_i = 0; (int)hv_i <= 3; hv_i = (int)hv_i + 1)
            {
                ho_four_rects_.Dispose();
                HOperatorSet.GenRegionPolygonFilled(out ho_four_rects_, ((((((((hv_four_rect_row1.TupleSelect(
                    hv_i))).TupleConcat(hv_four_rect_row2.TupleSelect(hv_i)))).TupleConcat(
                    hv_four_rect_row3.TupleSelect(hv_i)))).TupleConcat(hv_four_rect_row4.TupleSelect(
                    hv_i)))).TupleConcat(hv_four_rect_row1.TupleSelect(hv_i)), ((((((((hv_four_rect_col1.TupleSelect(
                    hv_i))).TupleConcat(hv_four_rect_col2.TupleSelect(hv_i)))).TupleConcat(
                    hv_four_rect_col3.TupleSelect(hv_i)))).TupleConcat(hv_four_rect_col4.TupleSelect(
                    hv_i)))).TupleConcat(hv_four_rect_col1.TupleSelect(hv_i)));
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_four_rects, ho_four_rects_, out ExpTmpOutVar_0
                        );
                    ho_four_rects.Dispose();
                    ho_four_rects = ExpTmpOutVar_0;
                }
                //(3)

                ho_test_glue_region.Dispose();
                HOperatorSet.Difference(ho_four_rects_, ho_inside_holder_inner_region, out ho_test_glue_region);
                //if ((int)(hv_holderVisible) != 0)
                //{
                //    ho_test_glue_region.Dispose();
                //    HOperatorSet.Difference(ho_four_rects_, ho_inside_holder_outer_region,
                //        out ho_test_glue_region);
                //}
                //else
                //{
                //    ho_test_glue_region.Dispose();
                //    HOperatorSet.Difference(ho_four_rects_, ho_inside_holder_inner_region,
                //        out ho_test_glue_region);
                //}
                ho_srcImage_glue_test.Dispose();
                HOperatorSet.ReduceDomain(ho_srcImage_reduced, ho_test_glue_region, out ho_srcImage_glue_test
                    );
                //(2)
                HOperatorSet.GrayHisto(ho_four_rects_, ho_srcImage_reduced, out hv_AbsoluteHisto,
                    out hv_RelativeHisto);
                Ostu_Threshold(hv_AbsoluteHisto, hv_probability_threshold, hv_grayvalue_threshold,
                    out hv_glue_thresh);
                //If glue is largely missing, the threshold can be wrong. Therefore I replace it with the overall ostu threshold.
                if ((int)(new HTuple(((((hv_glue_thresh - hv_glue_thresh_all)).TupleAbs()
                    )).TupleGreater(10))) != 0)
                {
                    hv_glue_thresh = hv_glue_thresh_all.Clone();
                }
                if ((int)(new HTuple(hv_thresh_offset.TupleGreater(0))) != 0)
                {
                    ho_srcImage_glue_test_inverted.Dispose();
                    HOperatorSet.InvertImage(ho_srcImage_glue_test, out ho_srcImage_glue_test_inverted
                        );
                    ho_glue_region_.Dispose();
                    HOperatorSet.HysteresisThreshold(ho_srcImage_glue_test_inverted, out ho_glue_region_,
                        255 - hv_glue_thresh, (255 - hv_glue_thresh) + hv_thresh_offset, 5);
                }
                else
                {
                    ho_glue_region_.Dispose();
                    HOperatorSet.Threshold(ho_srcImage_glue_test, out ho_glue_region_, 0,
                        hv_glue_thresh - hv_thresh_offset);
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.Union2(ho_glue_region, ho_glue_region_, out ExpTmpOutVar_0
                        );
                    ho_glue_region.Dispose();
                    ho_glue_region = ExpTmpOutVar_0;
                }
                #region //(2-2)20200306新增檢驗鏡片缺損
                HOperatorSet.Intersection(ho_four_rects_, ho_holder_scar_region, out ho_test_scar_region);
                HOperatorSet.ReduceDomain(ho_srcImage_reduced, ho_test_scar_region, out ho_srcImage_scar_test);
                if (My.NIR.DarkLightChoice_Scar == 0)//黑
                {
                    ho_srcImage_scar_test_inverted.Dispose();
                    HOperatorSet.InvertImage(ho_srcImage_scar_test, out ho_srcImage_scar_test_inverted);
                    ho_scar_region_.Dispose();
                    if (hv_scar_thresh_offset > 0)
                    {
                        HOperatorSet.HysteresisThreshold(ho_srcImage_scar_test_inverted, out ho_scar_region_,
                            255 - hv_glue_thresh, (255 - hv_glue_thresh) + hv_scar_thresh_offset, 5);
                    }
                    else
                    {
                        HOperatorSet.HysteresisThreshold(ho_srcImage_scar_test_inverted, out ho_scar_region_,
                                255 - hv_glue_thresh + hv_scar_thresh_offset, 255 - hv_glue_thresh, 5);
                    }
                }
                else
                {
                    ho_scar_region_.Dispose();
                    if (hv_scar_thresh_offset > 0)
                    {
                        HOperatorSet.HysteresisThreshold(ho_srcImage_scar_test, out ho_scar_region_,
                            255 - hv_glue_thresh, (255 - hv_glue_thresh) + hv_scar_thresh_offset, 5);
                    }
                    else
                    {
                        HOperatorSet.HysteresisThreshold(ho_srcImage_scar_test, out ho_scar_region_,
                                255 - hv_glue_thresh + hv_scar_thresh_offset, 255 - hv_glue_thresh, 5);
                    }
                }

                //if ((int)(new HTuple(hv_scar_thresh_offset.TupleGreater(0))) != 0)
                //{
                //    ho_srcImage_scar_test_inverted.Dispose();
                //    HOperatorSet.InvertImage(ho_srcImage_scar_test, out ho_srcImage_scar_test_inverted);
                //    ho_scar_region_.Dispose();
                //    HOperatorSet.HysteresisThreshold(ho_srcImage_scar_test_inverted, out ho_scar_region_,
                //        255 - hv_glue_thresh, (255 - hv_glue_thresh) + hv_scar_thresh_offset, 5);
                //}
                //else
                //{
                //    ho_scar_region_.Dispose();
                //    HOperatorSet.Threshold(ho_srcImage_scar_test, out ho_scar_region_, 0,
                //        hv_glue_thresh - hv_scar_thresh_offset);
                //}
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.Union2(ho_scar_region, ho_scar_region_, out ExpTmpOutVar_0
                        );
                    ho_scar_region.Dispose();
                    ho_scar_region = ExpTmpOutVar_0;
                }
                //到此
                #endregion

                double mm_2_pixel = 360.0;
                if (My.NIR.Check_ExcessiveGlue)
                {
                    switch (My.NIR.Mode_ExcessiveGlue)
                    {
                        case 1://禹丞方法自動計算亮點
                            {//(1)
                                #region//(4-1)
                                if ((int)(hv_holderVisible.TupleNot()) != 0)
                                {
                                    ho_test_leakage_region.Dispose();
                                    HOperatorSet.Intersection(ho_four_rects_, ho_inside_holder_inner_region,
                                        out ho_test_leakage_region);
                                }
                                else
                                {
                                    ho_four_rects_.Dispose();
                                    HOperatorSet.SelectObj(ho_four_rects, out ho_four_rects_, hv_i + 1);
                                    ho_test_leakage_region.Dispose();
                                    HOperatorSet.Intersection(ho_four_rects_, ho_inside_holder_outer_region,
                                        out ho_test_leakage_region);
                                }
                                ho_test_leakage_image.Dispose();
                                HOperatorSet.ReduceDomain(ho_srcImage_reduced, ho_test_leakage_region,
                                    out ho_test_leakage_image);
                                HOperatorSet.GrayHisto(ho_test_leakage_region, ho_srcImage_reduced, out hv_AbsoluteHisto,
                                    out hv_RelativeHisto);
                                hv_percent95_grayVal = 0;
                                for (hv_j = 1; (int)hv_j <= 255; hv_j = (int)hv_j + 1)
                                {
                                    if (hv_RelativeHisto == null)
                                        hv_RelativeHisto = new HTuple();
                                    hv_RelativeHisto[hv_j] = (hv_RelativeHisto.TupleSelect(hv_j - 1)) + (hv_RelativeHisto.TupleSelect(
                                        hv_j));
                                    if ((int)(new HTuple(((hv_RelativeHisto.TupleSelect(hv_j))).TupleGreater(
                                        0.95))) != 0)
                                    {
                                        hv_percent95_grayVal = hv_j.Clone();
                                        break;
                                    }
                                }
                                ho_leakage_region_.Dispose();
                                HOperatorSet.Threshold(ho_test_leakage_image, out ho_leakage_region_, hv_percent95_grayVal + hv_leakage_gray_offset,
                                    255);
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.Union2(ho_leakage_region, ho_leakage_region_, out ExpTmpOutVar_0
                                        );
                                    ho_leakage_region.Dispose();
                                    ho_leakage_region = ExpTmpOutVar_0;
                                }
                                #endregion
                            } break;
                        case 2:
                            {
                                #region 方法2
                                HObject ho_OuterCircle_ExcessiveGlue = new HObject(), ho_InnerCircle_ExcessiveGlue = new HObject(), ho_RegionDifference_ExcessiveGlue = new HObject();
                                HObject ho_RegionIntersection_ExcessiveGlue = new HObject(), ho_ImageReduce_ExcessiveGlue = new HObject(), ho_ImageInvert_ExcessiveGlue = new HObject();
                                HObject ho_Region_ExcessiveGlue = new HObject();
                                HTuple hv_OuterRadius_ExcessiveGlue = My.NIR.OuterRadius_ExcessiveGlue * mm_2_pixel / 1000 / 2;
                                HTuple hv_InnerRadius_ExcessiveGlue = My.NIR.InnerRadius_ExcessiveGlue * mm_2_pixel / 1000 / 2;
                                HTuple hv_Offset_ExcessiveGlue = My.NIR.OffSet_ExcessiveGlue;

                                ho_OuterCircle_ExcessiveGlue.Dispose();
                                HOperatorSet.GenCircle(out ho_OuterCircle_ExcessiveGlue, hv_CenterRow, hv_CenterColumn, hv_OuterRadius_ExcessiveGlue);
                                ho_InnerCircle_ExcessiveGlue.Dispose();
                                HOperatorSet.GenCircle(out ho_InnerCircle_ExcessiveGlue, hv_CenterRow, hv_CenterColumn, hv_InnerRadius_ExcessiveGlue);
                                ho_RegionDifference_ExcessiveGlue.Dispose();
                                HOperatorSet.Difference(ho_OuterCircle_ExcessiveGlue, ho_InnerCircle_ExcessiveGlue, out ho_RegionDifference_ExcessiveGlue);

                                ho_RegionIntersection_ExcessiveGlue.Dispose();
                                HOperatorSet.Intersection(ho_four_rects_, ho_RegionDifference_ExcessiveGlue, out ho_RegionIntersection_ExcessiveGlue);

                                ho_ImageReduce_ExcessiveGlue.Dispose();
                                HOperatorSet.ReduceDomain(ho_srcImage_reduced, ho_RegionIntersection_ExcessiveGlue, out ho_ImageReduce_ExcessiveGlue);
                                if (My.NIR.DarkLightChoice_ExcessiveGlue == 0)//黑
                                {
                                    ho_ImageInvert_ExcessiveGlue.Dispose();
                                    HOperatorSet.InvertImage(ho_ImageReduce_ExcessiveGlue, out ho_ImageInvert_ExcessiveGlue);
                                    ho_Region_ExcessiveGlue.Dispose();
                                    if (hv_Offset_ExcessiveGlue > 0)
                                    {
                                        HOperatorSet.HysteresisThreshold(ho_ImageInvert_ExcessiveGlue, out ho_Region_ExcessiveGlue,
                                            255 - hv_glue_thresh, (255 - hv_glue_thresh) + hv_Offset_ExcessiveGlue, 5);
                                    }
                                    else
                                    {
                                        HOperatorSet.HysteresisThreshold(ho_ImageInvert_ExcessiveGlue, out ho_Region_ExcessiveGlue,
                                                255 - hv_glue_thresh + hv_Offset_ExcessiveGlue, 255 - hv_glue_thresh, 5);
                                    }
                                }
                                else
                                {
                                    ho_Region_ExcessiveGlue.Dispose();
                                    if (hv_scar_thresh_offset > 0)
                                    {
                                        HOperatorSet.HysteresisThreshold(ho_ImageReduce_ExcessiveGlue, out ho_Region_ExcessiveGlue,
                                            255 - hv_glue_thresh, (255 - hv_glue_thresh) + hv_Offset_ExcessiveGlue, 5);
                                    }
                                    else
                                    {
                                        HOperatorSet.HysteresisThreshold(ho_ImageReduce_ExcessiveGlue, out ho_Region_ExcessiveGlue,
                                                255 - hv_glue_thresh + hv_Offset_ExcessiveGlue, 255 - hv_glue_thresh, 5);
                                    }
                                }

                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.Union2(ho_leakage_region, ho_Region_ExcessiveGlue, out ExpTmpOutVar_0
                                        );
                                    ho_leakage_region.Dispose();
                                    ho_leakage_region = ExpTmpOutVar_0;
                                }
                                ////HTuple hv_area = new HTuple(), hv_row = new HTuple(), hv_column = new HTuple();
                                ////HOperatorSet.AreaCenter(ho_leakage_region, out hv_area, out hv_row, out hv_column);
                                ho_OuterCircle_ExcessiveGlue.Dispose();
                                ho_InnerCircle_ExcessiveGlue.Dispose();
                                ho_RegionDifference_ExcessiveGlue.Dispose();
                                ho_RegionIntersection_ExcessiveGlue.Dispose();
                                ho_ImageReduce_ExcessiveGlue.Dispose();
                                ho_ImageInvert_ExcessiveGlue.Dispose();
                                ho_Region_ExcessiveGlue.Dispose();
                                #endregion
                            } break;
                    }
                }
            }
          
                           
            //20200306新增檢驗鏡片缺損

            HOperatorSet.CopyObj(ho_scar_region, out inside_scar_region, 1, -1);
            //到此
            //---Purpose---
            //*Determine if there is leakage based on the suspected bright region**

            //---Implementation----
            //1. Remove small regions
            //2. Only the bright region near the holder is regarded as leakage
            //3. Often the margin of the holder region will be falsely thresholded to be bright region
            //   and its shape is often of strip. To differentiate between real leakge and falsely selected
            //   birght region, I need to estimate the mean width of the strip. To accomplish this, I create
            //   the procedure "Get_Region_Angle_Range" whose goal is to calculate the mean width
            //   of the strip and the angle range of the strip.

            //>>>>>>>>>>>>>>>Parameter setting>>>>>>>>>>>>>>>
            //(closed)
            ////param-1//
            hv_leakage_min_area = 100;
            //Name: 最小溢胶面积
            //Tooltip: Any area less than this value is ignored
            //(opened-parameter)
            //<<<<<<<<<<<<<<Parameter setting<<<<<<<<<<<<<<<<<

            hv_leakage_flag = 0;
            if (My.NIR.Check_ExcessiveGlue)
            {
                #region 過濾溢膠
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.RemoveNoiseRegion(ho_leakage_region, out ExpTmpOutVar_0, "n_48");
                    ho_leakage_region.Dispose();
                    ho_leakage_region = ExpTmpOutVar_0;
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.Connection(ho_leakage_region, out ExpTmpOutVar_0);
                    ho_leakage_region.Dispose();
                    ho_leakage_region = ExpTmpOutVar_0;
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.SelectShape(ho_leakage_region, out ExpTmpOutVar_0, "area", "and",
                        hv_leakage_min_area, 1e10);
                    ho_leakage_region.Dispose();
                    ho_leakage_region = ExpTmpOutVar_0;
                }
                //(2)
                if ((int)(hv_holderVisible) != 0)
                {
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.SelectShapeProto(ho_leakage_region, ho_holder_region, out ExpTmpOutVar_0,
                            "overlaps_rel", 10, 100);
                        ho_leakage_region.Dispose();
                        ho_leakage_region = ExpTmpOutVar_0;
                    }
                }
                else
                {
                    ho_holder_border.Dispose();
                    HOperatorSet.Difference(ho_inside_holder_inner_region, ho_inside_holder_inner_region_retreated,
                        out ho_holder_border);
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.SelectShapeProto(ho_leakage_region, ho_holder_border, out ExpTmpOutVar_0,
                            "overlaps_rel", 10, 100);
                        ho_leakage_region.Dispose();
                        ho_leakage_region = ExpTmpOutVar_0;
                    }
                }

                HOperatorSet.CountObj(ho_leakage_region, out hv_leakage_region_count);
                if ((int)(new HTuple(hv_leakage_region_count.TupleNotEqual(0))) != 0)
                {
                    //(3)
                    hv_min_arc_length = 20;
                    if ((int)(hv_holderVisible) != 0)
                    {
                        //hv_radial_width_thresh = ((hv_holder_radius2 - hv_holder_radius1) - hv_holder_center_offset) / 1.414;
                    }
                    else
                    {
                        hv_radial_width_thresh = 5;
                    }
                    Get_Region_Angle_Range(ho_leakage_region, ho_srcImage, hv_CenterRow,
                        hv_CenterColumn, hv_min_arc_length, hv_radial_width_thresh, out hv_leak_pass_mask);
                    ho_leakage_region_pass.Dispose();
                    select_mask_obj(ho_leakage_region, out ho_leakage_region_pass, hv_leak_pass_mask);
                    HOperatorSet.CountObj(ho_leakage_region_pass, out hv_leakage_pass_count);
                    if ((int)(new HTuple(hv_leakage_pass_count.TupleNotEqual(0))) != 0)
                    {
                        hv_leakage_flag = 1;
                    }
                }
                HOperatorSet.CopyObj(ho_leakage_region, out leakage_region, 1, -1);
                #endregion
            }
            //---Purpose---
            //*Avoid the fringe effect which will cause the program to not include the border region into glue region**
            //---Implementation----
            //1. In the border region part, I decide the pixels which gradient direction is consistent, which means that the upper part should have
            //gradient in the direction of vertical and the gradient of the left and right should have gradient in the direction of horizontal.
            //2. For pixels which gradient is consistent and large enough, I think it is normal and should be include in the glue region

            //>>>>>>>>>>>>>>>Parameter setting>>>>>>>>>>>>>>>
            //(closed)
            //The offset of gradient direction that is allowed to be considered as consistent
            hv_edge_direction_range = 15;
            //The threshold for which the pixel is considered located at border
            hv_edge_region_thresh = 3;
            //Since there are many holes in the included border region, holes smaller than this value is filled
            hv_fill_area_thresh = 10;
            //The following value is used to sift out some noisy region
            hv_slope_area_min_area = 100;
            //(opened-parameter)
            ////param-1//
            //Name:
            //Tooltip:
            //<<<<<<<<<<<<<<Parameter setting<<<<<<<<<<<<<<<<<

            //(1)Making border region
            HOperatorSet.HomMat2dIdentity(out hv_transMat);
            HOperatorSet.HomMat2dRotate(hv_transMat, hv_target_rect_phi, 0, 0, out hv_transMat);
            HOperatorSet.HomMat2dTranslate(hv_transMat, hv_target_rect_row, hv_target_rect_col,
                out hv_transMat);
            hv_upper_border_row = new HTuple();
            hv_upper_border_row = hv_upper_border_row.TupleConcat(-hv_target_rect_length2);
            hv_upper_border_row = hv_upper_border_row.TupleConcat(-hv_target_rect_length2);
            hv_upper_border_row = hv_upper_border_row.TupleConcat((-hv_target_rect_length2) + hv_edge_range);
            hv_upper_border_row = hv_upper_border_row.TupleConcat((-hv_target_rect_length2) + hv_edge_range);
            hv_upper_border_row = hv_upper_border_row.TupleConcat(-hv_target_rect_length2);
            hv_upper_border_col = new HTuple();
            hv_upper_border_col = hv_upper_border_col.TupleConcat(-hv_target_rect_length1);
            hv_upper_border_col = hv_upper_border_col.TupleConcat(hv_target_rect_length1);
            hv_upper_border_col = hv_upper_border_col.TupleConcat(hv_target_rect_length1);
            hv_upper_border_col = hv_upper_border_col.TupleConcat(-hv_target_rect_length1);
            hv_upper_border_col = hv_upper_border_col.TupleConcat(-hv_target_rect_length1);
            hv_left_border_row = new HTuple();
            hv_left_border_row = hv_left_border_row.TupleConcat(-hv_target_rect_length2);
            hv_left_border_row = hv_left_border_row.TupleConcat(-hv_target_rect_length2);
            hv_left_border_row = hv_left_border_row.TupleConcat(hv_target_rect_length2);
            hv_left_border_row = hv_left_border_row.TupleConcat(hv_target_rect_length2);
            hv_left_border_row = hv_left_border_row.TupleConcat(-hv_target_rect_length2);
            hv_left_border_col = new HTuple();
            hv_left_border_col = hv_left_border_col.TupleConcat(-hv_target_rect_length1);
            hv_left_border_col = hv_left_border_col.TupleConcat((-hv_target_rect_length1) + hv_edge_range);
            hv_left_border_col = hv_left_border_col.TupleConcat((-hv_target_rect_length1) + hv_edge_range);
            hv_left_border_col = hv_left_border_col.TupleConcat(-hv_target_rect_length1);
            hv_left_border_col = hv_left_border_col.TupleConcat(-hv_target_rect_length1);
            hv_right_border_row = new HTuple();
            hv_right_border_row = hv_right_border_row.TupleConcat(-hv_target_rect_length2);
            hv_right_border_row = hv_right_border_row.TupleConcat(-hv_target_rect_length2);
            hv_right_border_row = hv_right_border_row.TupleConcat(hv_target_rect_length2);
            hv_right_border_row = hv_right_border_row.TupleConcat(hv_target_rect_length2);
            hv_right_border_row = hv_right_border_row.TupleConcat(-hv_target_rect_length2);
            hv_right_border_col = -hv_left_border_col;
            hv_lower_border_row = -hv_upper_border_row;
            hv_lower_border_col = new HTuple();
            hv_lower_border_col = hv_lower_border_col.TupleConcat(-hv_target_rect_length1);
            hv_lower_border_col = hv_lower_border_col.TupleConcat(hv_target_rect_length1);
            hv_lower_border_col = hv_lower_border_col.TupleConcat(hv_target_rect_length1);
            hv_lower_border_col = hv_lower_border_col.TupleConcat(-hv_target_rect_length1);
            hv_lower_border_col = hv_lower_border_col.TupleConcat(-hv_target_rect_length1);
            HOperatorSet.AffineTransPoint2d(hv_transMat, hv_upper_border_row, hv_upper_border_col,
                out hv_upper_border_row, out hv_upper_border_col);
            HOperatorSet.AffineTransPoint2d(hv_transMat, hv_lower_border_row, hv_lower_border_col,
                out hv_lower_border_row, out hv_lower_border_col);
            HOperatorSet.AffineTransPoint2d(hv_transMat, hv_left_border_row, hv_left_border_col,
                out hv_left_border_row, out hv_left_border_col);
            HOperatorSet.AffineTransPoint2d(hv_transMat, hv_right_border_row, hv_right_border_col,
                out hv_right_border_row, out hv_right_border_col);
            ho_upper_border_region.Dispose();
            HOperatorSet.GenRegionPolygonFilled(out ho_upper_border_region, hv_upper_border_row,
                hv_upper_border_col);
            ho_lower_border_region.Dispose();
            HOperatorSet.GenRegionPolygonFilled(out ho_lower_border_region, hv_lower_border_row,
                hv_lower_border_col);
            ho_left_border_region.Dispose();
            HOperatorSet.GenRegionPolygonFilled(out ho_left_border_region, hv_left_border_row,
                hv_left_border_col);
            ho_right_border_region.Dispose();
            HOperatorSet.GenRegionPolygonFilled(out ho_right_border_region, hv_right_border_row,
                hv_right_border_col);
            ho_all_fringe_region1.Dispose();
            HOperatorSet.Union2(ho_upper_border_region, ho_lower_border_region, out ho_all_fringe_region1
                );
            ho_all_fringe_region2.Dispose();
            HOperatorSet.Union2(ho_left_border_region, ho_right_border_region, out ho_all_fringe_region2
                );
            ho_all_fringe_region.Dispose();
            HOperatorSet.Union2(ho_all_fringe_region1, ho_all_fringe_region2, out ho_all_fringe_region
                );
            ho_edgeAmp.Dispose(); ho_edgeDir.Dispose();
            HOperatorSet.SobelDir(ho_srcImage_reduced, out ho_edgeAmp, out ho_edgeDir,
                "sum_abs", 3);

            ho_strong_edge_region.Dispose();
            HOperatorSet.Threshold(ho_edgeAmp, out ho_strong_edge_region, hv_edge_region_thresh,
                255);
            ho_edgeDir_reduced.Dispose();
            HOperatorSet.ReduceDomain(ho_edgeDir, ho_strong_edge_region, out ho_edgeDir_reduced
                );
            //Upper Part*
            ho_upper_border_image.Dispose();
            HOperatorSet.ReduceDomain(ho_edgeDir_reduced, ho_upper_border_region, out ho_upper_border_image
                );
            ho_upper_ignore_1.Dispose();
            HOperatorSet.Threshold(ho_upper_border_image, out ho_upper_ignore_1, 0, hv_edge_direction_range);
            ho_upper_ignore_2.Dispose();
            HOperatorSet.Threshold(ho_upper_border_image, out ho_upper_ignore_2, 180 - hv_edge_direction_range,
                180 + hv_edge_direction_range);
            ho_upper_border_region.Dispose();
            HOperatorSet.Union2(ho_upper_ignore_1, ho_upper_ignore_2, out ho_upper_border_region
                );
            ho_upper_border_region_filled.Dispose();
            My_Fillup(ho_upper_border_region, out ho_upper_border_region_filled, hv_fill_area_thresh);
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.Connection(ho_upper_border_region_filled, out ExpTmpOutVar_0);
                ho_upper_border_region_filled.Dispose();
                ho_upper_border_region_filled = ExpTmpOutVar_0;
            }
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.SelectShape(ho_upper_border_region_filled, out ExpTmpOutVar_0,
                    "area", "and", hv_slope_area_min_area, 1e10);
                ho_upper_border_region_filled.Dispose();
                ho_upper_border_region_filled = ExpTmpOutVar_0;
            }
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.Union1(ho_upper_border_region_filled, out ExpTmpOutVar_0);
                ho_upper_border_region_filled.Dispose();
                ho_upper_border_region_filled = ExpTmpOutVar_0;
            }
            //Lower Part*
            ho_lower_border_image.Dispose();
            HOperatorSet.ReduceDomain(ho_edgeDir_reduced, ho_lower_border_region, out ho_lower_border_image
                );
            ho_lower_border_region.Dispose();
            HOperatorSet.Threshold(ho_lower_border_image, out ho_lower_border_region, 90 - hv_edge_direction_range,
                90 + hv_edge_direction_range);
            ho_lower_border_region_filled.Dispose();
            My_Fillup(ho_lower_border_region, out ho_lower_border_region_filled, hv_fill_area_thresh);
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.Connection(ho_lower_border_region_filled, out ExpTmpOutVar_0);
                ho_lower_border_region_filled.Dispose();
                ho_lower_border_region_filled = ExpTmpOutVar_0;
            }
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.SelectShape(ho_lower_border_region_filled, out ExpTmpOutVar_0,
                    "area", "and", hv_slope_area_min_area, 1e10);
                ho_lower_border_region_filled.Dispose();
                ho_lower_border_region_filled = ExpTmpOutVar_0;
            }
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.Union1(ho_lower_border_region_filled, out ExpTmpOutVar_0);
                ho_lower_border_region_filled.Dispose();
                ho_lower_border_region_filled = ExpTmpOutVar_0;
            }
            //Left Part*
            ho_left_border_image.Dispose();
            HOperatorSet.ReduceDomain(ho_edgeDir_reduced, ho_left_border_region, out ho_left_border_image
                );
            ho_left_border_region.Dispose();
            HOperatorSet.Threshold(ho_left_border_image, out ho_left_border_region, 45 - hv_edge_direction_range,
                45 + hv_edge_direction_range);
            ho_left_border_region_filled.Dispose();
            My_Fillup(ho_left_border_region, out ho_left_border_region_filled, hv_fill_area_thresh);
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.Connection(ho_left_border_region_filled, out ExpTmpOutVar_0);
                ho_left_border_region_filled.Dispose();
                ho_left_border_region_filled = ExpTmpOutVar_0;
            }
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.SelectShape(ho_left_border_region_filled, out ExpTmpOutVar_0,
                    "area", "and", hv_slope_area_min_area, 1e10);
                ho_left_border_region_filled.Dispose();
                ho_left_border_region_filled = ExpTmpOutVar_0;
            }
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.Union1(ho_left_border_region_filled, out ExpTmpOutVar_0);
                ho_left_border_region_filled.Dispose();
                ho_left_border_region_filled = ExpTmpOutVar_0;
            }
            //Right Part*
            ho_right_border_image.Dispose();
            HOperatorSet.ReduceDomain(ho_edgeDir_reduced, ho_right_border_region, out ho_right_border_image
                );
            ho_right_border_region.Dispose();
            HOperatorSet.Threshold(ho_right_border_image, out ho_right_border_region, 135 - hv_edge_direction_range,
                135 + hv_edge_direction_range);
            ho_right_border_region_filled.Dispose();
            My_Fillup(ho_right_border_region, out ho_right_border_region_filled, hv_fill_area_thresh);
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.Connection(ho_right_border_region_filled, out ExpTmpOutVar_0);
                ho_right_border_region_filled.Dispose();
                ho_right_border_region_filled = ExpTmpOutVar_0;
            }
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.SelectShape(ho_right_border_region_filled, out ExpTmpOutVar_0,
                    "area", "and", hv_slope_area_min_area, 1e10);
                ho_right_border_region_filled.Dispose();
                ho_right_border_region_filled = ExpTmpOutVar_0;
            }
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.Union1(ho_right_border_region_filled, out ExpTmpOutVar_0);
                ho_right_border_region_filled.Dispose();
                ho_right_border_region_filled = ExpTmpOutVar_0;
            }

            ho_fringe_region1.Dispose();
            HOperatorSet.Union2(ho_left_border_region_filled, ho_right_border_region_filled,
                out ho_fringe_region1);
            ho_fringe_region2.Dispose();
            HOperatorSet.Union2(ho_upper_border_region_filled, ho_lower_border_region_filled,
                out ho_fringe_region2);
            ho_fringe_region.Dispose();
            HOperatorSet.Union2(ho_fringe_region1, ho_fringe_region2, out ho_fringe_region
                );

            //---Purpose---
            //*There are many dark regions in the center which are not glue, so it should be removed
            //---Implementation----
            //1. Any dark region that has too many area in the center is not considered as glue.

            //*Remove center dark
            //ho_glue_region_connected.Dispose();
            //HOperatorSet.Connection(ho_glue_region, out ho_glue_region_connected);
            //ho_ignore_circle.Dispose();
            //HOperatorSet.GenCircle(out ho_ignore_circle, hv_sample_center_row, hv_sample_center_col,
            //    hv_ignore_radius);
            //{
            //    HObject ExpTmpOutVar_0;
            //    HOperatorSet.SelectShapeProto(ho_glue_region_connected, ho_ignore_circle, out ExpTmpOutVar_0,
            //         "overlaps_rel", 0, 30);
            //     ho_glue_region_connected.Dispose();
            //     ho_glue_region_connected = ExpTmpOutVar_0;
            // }
            // ho_glue_region.Dispose();
            // HOperatorSet.Union1(ho_glue_region_connected, out ho_glue_region);

            //Region not counted as glue because of fringe effect is now include
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.Union2(ho_fringe_region, ho_glue_region, out ExpTmpOutVar_0);
                ho_glue_region.Dispose();
                ho_glue_region = ExpTmpOutVar_0;
            }
            //HTuple row, column, area;
            //HOperatorSet.AreaCenter(ho_glue_region, out area, out row, out column);

            if (mode == 1)
            {
                //---Purpose---
                //*Detect spots**
                //---Implementation----
                //1. Since the sample has a circularly symmetric pattern, I use polar transform to make it have
                //layered pattern.
                //2. Then it is a simple mean and threshold.

                //>>>>>>>>>>>>>>>Parameter setting>>>>>>>>>>>>>>>
                //(closed)
                //(opened-parameter)
                ////param-7//
                hv_spot_threshold = parameter_set["spot_threshold"];
                //Name: 亮点阀值

                //<<<<<<<<<<<<<<Parameter setting<<<<<<<<<<<<<<<<<
                hv_polar_width = 1024;
                hv_polar_height = 128;
                ho_polar_image.Dispose();
                HOperatorSet.PolarTransImageExt(ho_srcImage_reduced, out ho_polar_image, hv_CenterRow,
                    hv_CenterColumn, 0, (new HTuple(360)).TupleRad(), 0, hv_CenterRadius,
                    hv_polar_width, hv_polar_height, "nearest_neighbor");
                ho_poar_image_mean_0.Dispose();
                HOperatorSet.MeanImage(ho_polar_image, out ho_poar_image_mean_0, 4, 3);
                ho_spot_region_polar.Dispose();
                HOperatorSet.MeanImage(ho_polar_image, out ho_poar_image_mean, 1024, 3);
                ho_spot_region_polar.Dispose();
                HOperatorSet.DynThreshold(ho_poar_image_mean_0, ho_poar_image_mean, out ho_spot_region_polar,
                    hv_spot_threshold, "light");
                ho_spot_region.Dispose();
                HOperatorSet.PolarTransRegionInv(ho_spot_region_polar, out ho_spot_region,
                    hv_CenterRow, hv_CenterColumn, 0, (new HTuple(360)).TupleRad()
                    , 0, hv_CenterRadius, hv_polar_width, hv_polar_height, hv_srcWidth, hv_srcHeight,
                    "nearest_neighbor");


                HObject ho_OuterCircle = new HObject(),ho_InnerCircle = new HObject(),ho_RegionDifference = new HObject();
                ho_OuterCircle.Dispose();
                HOperatorSet.GenCircle(out ho_OuterCircle, hv_CenterRow, hv_CenterColumn, My.NIR.OuterRadius_Paricle * My.NIR.mm_2_pixel / 1000 / 2);
                ho_InnerCircle.Dispose();
                HOperatorSet.GenCircle(out ho_InnerCircle, hv_CenterRow, hv_CenterColumn, My.NIR.InnerRadius_Paricle * My.NIR.mm_2_pixel / 1000 / 2);
                ho_RegionDifference.Dispose();
                HOperatorSet.Difference(ho_OuterCircle, ho_InnerCircle, out ho_RegionDifference);
                spot_region.Dispose();
                HOperatorSet.Intersection(ho_RegionDifference, ho_spot_region, out spot_region);
                //清除
                ho_OuterCircle.Dispose();
                ho_InnerCircle.Dispose();
                ho_RegionDifference.Dispose();
                //HOperatorSet.CopyObj(ho_spot_region, out spot_region, 1, -1);
            }

            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.OpeningCircle(ho_glue_region, out ExpTmpOutVar_0, 7.5);
                ho_glue_region.Dispose();
                ho_glue_region = ExpTmpOutVar_0;
            }
            //HOperatorSet.AreaCenter(ho_glue_region, out area, out row, out column);
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.Connection(ho_glue_region, out ExpTmpOutVar_0);
                ho_glue_region.Dispose();
                ho_glue_region = ExpTmpOutVar_0;
            }
            
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.SelectShape(ho_glue_region, out ExpTmpOutVar_0, "area", "and",
                    hv_glue_min_area, 10000000);
                ho_glue_region.Dispose();
                ho_glue_region = ExpTmpOutVar_0;
            }
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.Union1(ho_glue_region, out ExpTmpOutVar_0);
                ho_glue_region.Dispose();
                ho_glue_region = ExpTmpOutVar_0;
            }
            {
                HObject ExpTmpOutVar_0;
                My_Fillup_Intensity(ho_srcImage_reduced, ho_glue_region, out ExpTmpOutVar_0,
                    10, hv_glue_thresh + 10);
                ho_glue_region.Dispose();
                ho_glue_region = ExpTmpOutVar_0;
            }
            HOperatorSet.CopyObj(ho_glue_region, out glue_region, 1, -1);

         

            HTuple hv_maxDistance, hv_minDistance;
            HOperatorSet.DistancePr(ho_glue_region, hv_CenterRow, hv_CenterColumn, out hv_minDistance, out hv_maxDistance);
            result.minDistance = hv_minDistance.D * 2.35 * 2 * 1000 / (hv_target_rect_length1 + hv_target_rect_length2 + 0.0);
            //---Purpose---
            //*Decide whether the sample is okay according to criteria**
            //---Implementation----
            //1. Nothing to explain

            //>>>>>>>>>>>>>>>Parameter setting>>>>>>>>>>>>>>>
            //(opened-parameter)
            ////param-9//
            hv_red_cyan_radius = parameter_set["red_cyan_radius"];
            //Name: 红色青色交界半径
            //Tooltip:
            ////param-10//
            hv_yellow_red_radius = parameter_set["yellow_red_radius"];
            //Name: 红色黄色交界半径
            //Tooltip:
            ////param-11//
            hv_yellow_radius = parameter_set["yellow_inner_radius"];
            //Name: 黄色内部半径
            //Tooltip:
            //<<<<<<<<<<<<<<Parameter setting<<<<<<<<<<<<<<<<<
            ho_yellow_region.Dispose();
            HOperatorSet.GenCircle(out ho_yellow_region, hv_CenterRow, hv_CenterColumn,
                hv_yellow_red_radius);


            ho_red_region.Dispose();
            HOperatorSet.GenCircle(out ho_red_region, hv_CenterRow, hv_CenterColumn,
                hv_red_cyan_radius);

            ho_cyan_region.Dispose();
            HOperatorSet.Difference(ho_target_rect, ho_red_region, out ho_cyan_region);
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.Difference(ho_red_region, ho_yellow_region, out ExpTmpOutVar_0
                    );
                ho_red_region.Dispose();
                ho_red_region = ExpTmpOutVar_0;
            }
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.Intersection(ho_red_region, ho_target_rect, out ExpTmpOutVar_0
                    );
                ho_red_region.Dispose();
                ho_red_region = ExpTmpOutVar_0;
            }

            {
                HObject ho_yellow_inner_region = new HObject();
                HOperatorSet.GenCircle(out ho_yellow_inner_region, hv_CenterRow, hv_CenterColumn, hv_yellow_radius);
                HObject ExpTmpOutVar_0;
                HOperatorSet.Difference(ho_yellow_region, ho_yellow_inner_region,
                    out ExpTmpOutVar_0);
                ho_yellow_region.Dispose();
                ho_yellow_region = ExpTmpOutVar_0;
                ho_yellow_inner_region.Dispose();
            }


            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.Intersection(ho_yellow_region, ho_target_rect, out ExpTmpOutVar_0
                    );
                ho_yellow_region.Dispose();
                ho_yellow_region = ExpTmpOutVar_0;
            }
            //20200306新增 為了檢驗內有效面缺陷
            //HObject ho_glue_inside_holder_region = null;
            //HOperatorSet.GenEmptyObj(out ho_glue_inside_holder_region);
            //ho_glue_inside_holder_region.Dispose();
            //HOperatorSet.Intersection(ho_glue_region, ho_inside_holder_inner_region_retreated, out ho_glue_inside_holder_region);
            //HOperatorSet.CopyObj(ho_glue_inside_holder_region, out inside_scar_region, 1, -1);
            //HTuple hv_area = null,hv_arearow = null,hv_areacolumn = null;
            //HOperatorSet.AreaCenter(ho_inside_holder_inner_region_retreated, out hv_area, out hv_arearow, out hv_areacolumn);
            if (hv_leakage_flag == 1)
                result.leakage_flag = true;
            else
                result.leakage_flag = false;

            if ((int)(hv_holderVisible) != 0)
            {
                ho_ideal_glue_region.Dispose();
                HOperatorSet.Difference(ho_target_rect, ho_inside_holder_outer_region, out ho_ideal_glue_region
                    );
                HOperatorSet.AreaCenter(ho_ideal_glue_region, out hv_ideal_glue_area, out hv_dummy,
                    out hv_dummy);
            }
            else
            {
                ho_ideal_glue_region.Dispose();
                HOperatorSet.Difference(ho_target_rect, ho_inside_holder_inner_region, out ho_ideal_glue_region
                    );
                HOperatorSet.AreaCenter(ho_ideal_glue_region, out hv_ideal_glue_area, out hv_dummy,
                    out hv_dummy);
            }
            HOperatorSet.AreaCenter(ho_glue_region, out hv_glue_area, out hv_dumm, out hv_dummy);
            //20200227原來的四個角整體計算,跟4個角個別計算有數據上差異,故隱藏
            //hv_all_glue_area_ratio = (hv_glue_area + 0.0) / (hv_ideal_glue_area + 0.0) * 100;
            //result.all_ratio = (int)hv_all_glue_area_ratio.D;

            HOperatorSet.TupleGenConst(4, -1, out hv_yellow_area_ratios);
            HOperatorSet.TupleGenConst(4, -1, out hv_cyan_area_ratios);
            HOperatorSet.TupleGenConst(4, -1, out hv_red_area_ratios);


            for (hv_i = 1; (int)hv_i <= 4; hv_i = (int)hv_i + 1)
            {
                ho_four_rects_.Dispose();
                HOperatorSet.SelectObj(ho_four_rects, out ho_four_rects_, hv_i);
                ho_red_region_.Dispose();
                HOperatorSet.Intersection(ho_red_region, ho_four_rects_, out ho_red_region_
                    );
                ho_yellow_region_.Dispose();
                HOperatorSet.Intersection(ho_yellow_region, ho_four_rects_, out ho_yellow_region_
                    );
                ho_cyan_region_.Dispose();
                HOperatorSet.Intersection(ho_cyan_region, ho_four_rects_, out ho_cyan_region_
                    );
                HOperatorSet.AreaCenter(ho_red_region_, out hv_red_area, out hv_dummy, out hv_dummy);
                HOperatorSet.AreaCenter(ho_yellow_region_, out hv_yellow_area, out hv_dummy,
                    out hv_dummy);
                HOperatorSet.AreaCenter(ho_cyan_region_, out hv_cyan_area, out hv_dummy,
                    out hv_dummy);
                ho_red_glue_region_.Dispose();
                HOperatorSet.Intersection(ho_red_region_, ho_glue_region, out ho_red_glue_region_
                    );
                ho_yellow_glue_region_.Dispose();
                HOperatorSet.Intersection(ho_yellow_region_, ho_glue_region, out ho_yellow_glue_region_
                    );
                ho_cyan_glue_region_.Dispose();
                HOperatorSet.Intersection(ho_cyan_region_, ho_glue_region, out ho_cyan_glue_region_
                    );
                HOperatorSet.AreaCenter(ho_red_glue_region_, out hv_red_glue_area, out hv_dummy,
                    out hv_dummy);
                HOperatorSet.AreaCenter(ho_yellow_glue_region_, out hv_yellow_glue_area,
                    out hv_dummy, out hv_dummy);
                HOperatorSet.AreaCenter(ho_cyan_glue_region_, out hv_cyan_glue_area, out hv_dummy,
                    out hv_dummy);

                if (hv_red_area.D > 0)
                    hv_red_ratio = (hv_red_glue_area + 0.0) / (hv_red_area + 0.0) * 100;
                else
                    hv_red_ratio = 0;

                if (hv_cyan_area.D > 0)
                    hv_cyan_ratio = (hv_cyan_glue_area + 0.0) / (hv_cyan_area + 0.0) * 100;
                else
                    hv_cyan_ratio = -1;

                if (hv_yellow_area.D > 0)
                    hv_yellow_ratio = (hv_yellow_glue_area + 0.0) / (hv_yellow_area + 0.0) * 100;
                else
                    hv_yellow_ratio = -1;

                if (hv_red_area + hv_yellow_area + hv_cyan_area > 0)
                    hv_four_area_ratio_ = (hv_red_glue_area + hv_yellow_glue_area + hv_cyan_glue_area + 0.0) / (hv_red_area + hv_yellow_area + hv_cyan_area + 0.0) * 100;
                else
                    hv_four_area_ratio_ = -1;

                result.four_red_ratio[hv_i - 1] = (int)(hv_red_ratio.D);
                result.four_cyan_ratio[hv_i - 1] = (int)(hv_cyan_ratio.D);
                result.four_yellow_ratio[hv_i - 1] = (int)(hv_yellow_ratio.D);
                result.four_ratio[hv_i - 1] = (int)(hv_four_area_ratio_.D);
                result.all_ratio = (int)((result.four_ratio[0] + result.four_ratio[1] + result.four_ratio[2] + result.four_ratio[3]) / 4);
            }
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_srcImage.Dispose();
            ho_target_rect.Dispose();
            ho_srcImage_reduced.Dispose();
            ho_overall_dark_region.Dispose();
            ho_overall_dark_region_eroded.Dispose();
            ho_inside_holder_inner_region.Dispose();
            ho_inside_holder_inner_region_retreated.Dispose();
            ho_inside_holder_outer_region.Dispose();
            ho_holder_region.Dispose();
            ho_four_rects.Dispose();
            ho_glue_region.Dispose();
            ho_leakage_region.Dispose();
            ho_four_rects_.Dispose();
            ho_four_rect_holder.Dispose();
            ho_srcImage_histogram_.Dispose();
            ho_srcImage_histogram_inverted.Dispose();
            ho_glue_region_.Dispose();
            ho_test_leakage_region.Dispose();
            ho_test_leakage_image.Dispose();
            ho_leakage_region_.Dispose();
            ho_holder_image.Dispose();
            ho_holder_border.Dispose();
            ho_leakage_region_pass.Dispose();
            ho_upper_border_region.Dispose();
            ho_lower_border_region.Dispose();
            ho_left_border_region.Dispose();
            ho_right_border_region.Dispose();
            ho_all_fringe_region1.Dispose();
            ho_all_fringe_region2.Dispose();
            ho_all_fringe_region.Dispose();
            ho_edgeAmp.Dispose();
            ho_edgeDir.Dispose();
            ho_strong_edge_region.Dispose();
            ho_edgeDir_reduced.Dispose();
            ho_upper_border_image.Dispose();
            ho_upper_ignore_1.Dispose();
            ho_upper_ignore_2.Dispose();
            ho_upper_border_region_filled.Dispose();
            ho_lower_border_image.Dispose();
            ho_lower_border_region_filled.Dispose();
            ho_left_border_image.Dispose();
            ho_left_border_region_filled.Dispose();
            ho_right_border_image.Dispose();
            ho_right_border_region_filled.Dispose();
            ho_fringe_region1.Dispose();
            ho_fringe_region2.Dispose();
            ho_fringe_region.Dispose();
            ho_glue_region_connected.Dispose();
            ho_ignore_circle.Dispose();
            ho_polar_image.Dispose();
            ho_poar_image_mean.Dispose();
            ho_spot_region_polar.Dispose();
            ho_spot_region.Dispose();
            ho_yellow_region.Dispose();
            ho_red_region.Dispose();
            ho_cyan_region.Dispose();
            ho_ideal_glue_region.Dispose();
            ho_red_region_.Dispose();
            ho_yellow_region_.Dispose();
            ho_cyan_region_.Dispose();
            ho_red_glue_region_.Dispose();
            ho_yellow_glue_region_.Dispose();
            ho_cyan_glue_region_.Dispose();
            ho_test_glue_region.Dispose();
            ho_srcImage_glue_test.Dispose();
            ho_srcImage_glue_test_inverted.Dispose();
            if (!File.Exists("error.txt"))
            {
                File.Create("error.txt");
            }
            using (StreamWriter sw = new StreamWriter("error.txt", append: true))
            {
                sw.WriteLine("Exception: {0}\n{1}\n", System.DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"), HDevExpDefaultException.ToString());
            }
            return -999;
        }
        ho_srcImage.Dispose();
        ho_target_rect.Dispose();
        ho_srcImage_reduced.Dispose();
        ho_overall_dark_region.Dispose();
        ho_overall_dark_region_eroded.Dispose();
        ho_inside_holder_inner_region.Dispose();
        ho_inside_holder_inner_region_retreated.Dispose();
        ho_inside_holder_outer_region.Dispose();
        ho_holder_region.Dispose();
        ho_four_rects.Dispose();
        ho_glue_region.Dispose();
        ho_leakage_region.Dispose();
        ho_four_rects_.Dispose();
        ho_four_rect_holder.Dispose();
        ho_srcImage_histogram_.Dispose();
        ho_srcImage_histogram_inverted.Dispose();
        ho_glue_region_.Dispose();
        ho_test_leakage_region.Dispose();
        ho_test_leakage_image.Dispose();
        ho_leakage_region_.Dispose();
        ho_holder_image.Dispose();
        ho_holder_border.Dispose();
        ho_leakage_region_pass.Dispose();
        ho_upper_border_region.Dispose();
        ho_lower_border_region.Dispose();
        ho_left_border_region.Dispose();
        ho_right_border_region.Dispose();
        ho_all_fringe_region1.Dispose();
        ho_all_fringe_region2.Dispose();
        ho_all_fringe_region.Dispose();
        ho_edgeAmp.Dispose();
        ho_edgeDir.Dispose();
        ho_strong_edge_region.Dispose();
        ho_edgeDir_reduced.Dispose();
        ho_upper_border_image.Dispose();
        ho_upper_ignore_1.Dispose();
        ho_upper_ignore_2.Dispose();
        ho_upper_border_region_filled.Dispose();
        ho_lower_border_image.Dispose();
        ho_lower_border_region_filled.Dispose();
        ho_left_border_image.Dispose();
        ho_left_border_region_filled.Dispose();
        ho_right_border_image.Dispose();
        ho_right_border_region_filled.Dispose();
        ho_fringe_region1.Dispose();
        ho_fringe_region2.Dispose();
        ho_fringe_region.Dispose();
        ho_glue_region_connected.Dispose();
        ho_ignore_circle.Dispose();
        ho_polar_image.Dispose();
        ho_poar_image_mean.Dispose();
        ho_spot_region_polar.Dispose();
        ho_spot_region.Dispose();
        ho_yellow_region.Dispose();
        ho_red_region.Dispose();
        ho_cyan_region.Dispose();
        ho_ideal_glue_region.Dispose();
        ho_red_region_.Dispose();
        ho_yellow_region_.Dispose();
        ho_cyan_region_.Dispose();
        ho_red_glue_region_.Dispose();
        ho_yellow_glue_region_.Dispose();
        ho_cyan_glue_region_.Dispose();
        ho_test_glue_region.Dispose();
        ho_srcImage_glue_test.Dispose();
        ho_srcImage_glue_test_inverted.Dispose();
        return 0;
    }
    public int Query_Sample_Center(HObject ho_srcImage, out HTuple row, out HTuple col)
    {
        row = col = -1;
        if (!template_ready)
            return -1;
        HTuple hv_Angle = null, hv_Score = null;
        // Initialize local and output iconic variables 
        HOperatorSet.FindNccModel(ho_srcImage, this.hv_sample_NCC_ModelID, -((new HTuple(parameter_set["angle_range"])).TupleRad()
            ), (new HTuple(2 * parameter_set["angle_range"])).TupleRad(), 0.3, 1, 0, "true", 0, out row, out col,
            out hv_Angle, out hv_Score);
        if (row.Length == 0)
            return -1;
        return 0;
    }
}
